<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack-TypeScript-18]]></title>
    <url>%2F2019%2F08%2F16%2Fwebpack-TypeScript-18%2F</url>
    <content type="text"><![CDATA[TypeScript是javascript的扩展语言，可以规范我们的代码，并对代码进行相应的报错提示。可以有效提升javascript代码的可维护性。这篇来看下在webpack中的配置。TypeScript官方文档. ¶1. typescript打包配置 创建一个文件夹typeScript并初始化。 12npm init -y // 初始化文件夹npm install webpack webpack-cli -save-dev // 安装webpack以及webpack-cli脚手架 在文件夹下面新建src文件夹和webpack.config.js，index.tsx，typescript目录结构如下： 123456+ |- node-modules+ |- src+ |- index.tsx+ |- package.json+ |- package-lock.json+ |- webpack.config.js index.tsx 12345678910111213+ // 定义Greeter类。并创建button按钮点击在弹窗跳出Say Hello+ class Greeter &#123;+ greeting: string;+ constructor(message: string) &#123; + this.greeting = message;+ &#125;+ greet() &#123;+ return "hello, " + this.greeting+ &#125;+ &#125;+ + let greeter = new Greeter("world");+ alert(greeter.greet()); webpack.config.js 1234567891011121314151617+ const path = require('path');+ + module.exports = &#123;+ mode: 'production',+ entry: './src/index.tsx',+ module: &#123;+ rules: [&#123;+ test: /\.tsx?$/, // 配置tsx文件打包规则+ use: 'ts-loader',+ exclude: /node_modules/,+ &#125;],+ &#125;,+ output: &#123;+ filename: 'bundle.js',+ path: path.resolve(__dirname, 'dist'),+ &#125;,+ &#125; 上面我们打包tsx文件需要用到ts-loader,还需要安装typescript。现在安装下： npm install ts-loader typescript --save-dev。 这里要注意的是，在打包ts文件时，一定要在项目根目录下新建tsconfig.json。tsconfig.json文档。为了更好的设置tsx编译所需的参数而存在的文件。 tsconfig.json 12345678+ &#123;+ "compilerOptions": &#123;+ "outDir": "./dist", // 打包输出路径，写不写都行，webpack.config.js已配置+ "module": "es6", // 引入包用的是es6的+ "target": "es5", // 转化成最终的语法，这里将打包文件转化成es5的语法+ "allowJs": true, // 允许在typescript文件中引入js模块的文件+ &#125;+ &#125; 配置package.json打包命令 123+ "scripts": &#123;+ "build": "webpack" + &#125;, 配置完成后，执行打包命令 npm run build。打包完成，将生成的bundle.js文件复制到浏览器控制台，回车。可以看到网页弹出hello world ¶2.typescript 中引入第三方库，配置相应的语法提示 安装 lodash, @types/lodash 12+ npm install lodash --save-dev // 安装lodash 插件+ npm install @types/lodash --save-dev // 安装第三方语法检测插件 index.tsx 12345678910111213141516// 定义Greeter类。并创建button按钮点击在弹窗跳出Say Hello+ import * as _ from 'lodash'; // ts文件中引入第三方模块必须重命名引入，不然会报错class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123;- // return "hello, " + this.greeting+ return _.join(['hello', this.greeting], ''); &#125;&#125;let greeter = new Greeter("world");alert(greeter.greet()); 这样就配置好了第三方语法检测。如果安装jquery语法检测，就需要安装@types/jquery。那么如何知道这个插件是否存在呢。进入github，搜索types找DefinitelyTyped/DefinitelyTyped，点击进入到types搜索页面。就可以搜索你想要的类型检测插件。在点进去的页面上找TypeSearch]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-library打包-17]]></title>
    <url>%2F2019%2F08%2F15%2Fwebpack-library%E6%89%93%E5%8C%85-17%2F</url>
    <content type="text"><![CDATA[我们一般都是进行业务开发。那么如果想做一个库文件，供大家使用，webpack该如何打包呢？接着往下看 ¶1.编写打包文件 新建一个项目，如library。进入到library目录下，执行npm init -y初始化文件夹。在文件夹下新建src文件夹。并新建文件math.js,str.js， index.js。 执行npm init -y 1npm init -y //初始化文件 先来看下目录结构 12345678+ |- node-modules+ |- src+ |- index.js+ |- math.js+ |- str.js+ |- package.json+ |- package-lock.json+ |- webpack.config.js math.js 导出计算方法 12345678910111213+ export function add(a, b)&#123;+ return a + b+ &#125;+ + export function minus(a, b)&#123;+ return a - b+ &#125;+ export function multiply(a, b)&#123;+ return a * b+ &#125;+ export function division(a, b)&#123;+ return a / b+ &#125; str.js 导出字符串拼接方法 123+ export function join(a, b)&#123;+ return a + ''+ b;+ &#125; index.js 1234+ import * as math from './math.js';+ import * as str from './str.js'+ + export default &#123; math, str &#125; webpack.config.js, 默认的配置文件 1234567891011121314151617181920+ const path = require('path');+ const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin'); // 方便我们重复打包文件的更新+ const HtmlWebpackPlugin = require('html-webpack-plugin'); // 打包文件自动生成入口页面文件+ + module.exports = &#123;+ mode: 'production', + entry: './src/index.js', + output: &#123;+ path: path.resolve(__dirname, 'dist'), + filename: 'library.js', + library: 'library', // 类库名称+ libraryTarget: 'umd', // 初始化类库加载方式，默认为AMD。包含CommonJS， CMD+ &#125;,+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: 'test',+ &#125;),+ new CleanWebpackPlugin(),+ ]+ &#125; 编写类库library和libraryTarget这两个配置一般都要写上。umd是初始化类库加载方式，我们编写的库文件直接打包是无法让别人使用的。需要umd将我们的库暴露出去。这样才可以被调用。如果想在页面直接用script的方式直接引入，则需配置library: 'library'。 package.json 配置打包命令 1234567891011121314151617181920&#123; "name": "library", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123;+ "build": "webpack" &#125;, "keywords": [], "author": "yagm", "license": "MIT", "dependencies": &#123; "webpack": "^4.39.2", "webpack-cli": "^3.3.6" &#125;, "devDependencies": &#123; "clean-webpack-plugin": "^3.0.0", "html-webpack-plugin": "^3.2.0" &#125;&#125; 上面的配置我们使用了清除文件插件clean-webpack-plugin与自动生成入口页面文件html-webpack-plugin。所以要记得安装这两个插件。 npm install --save-dev clean-webpack-plugin, npm install --save-dev html-webpack-plugin。 配置完成后，执行打包命令npm run build。在浏览器打开生成的index.html文件。打开控制台，输入library，回车，可以看到math和str文件中的方法都被成功打印。 ¶2.externals 当我们在类库文件中引入lodash,用户在使用我们的库的同时，自己也引入了lodash这个库，那么就会打包2份lodash。这无疑让打包文件变的更大。 那么externals，就是解决这个问题的。 externals当库文件和用户文件同时引入一些库时，将库名列入到externals配置中。那么，库文件就只在用户文件中进行引用。打包一次即可。 修改 str.js 安装lodash， npm install lodash --save 1234+ import _ from 'lodash'export function join(a, b)&#123;+ return _.join([a, b], '')&#125; 执行打包命令 npm run build library.js文件打包的大小为71.2kb 设置externals 12345678910111213141516171819202122const path = require('path');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'production', entry: './src/index.js',+ externals: ['lodash'], output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'library.js', library: 'library', libraryTarget: 'umd', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'test', &#125;), new CleanWebpackPlugin(), ]&#125; 执行打包命令 npm run build library.js文件打包的大小为1.63kb。这样就实现了单次打包库文件。 ¶3.包发布 我们写好的库文件，别人要怎么下载使用呢？将打包的文件上传到git,将package.json文件的main入口改成git的下载地址。打开npm官网，注册账号。 123npm adduser &lt;你的用户名&gt; // npm 上添加你的用户名npm publish // npm发布包npm install // 别人使用，直接下载安装 这篇文章只是简单的记录下如何编写库文件以及发布包。正常写一个库文件 需要很多配置。希望大家不要随便上传一些无用的包。尽量维护npm社区包的质量。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-环境变量-16]]></title>
    <url>%2F2019%2F08%2F12%2Fwebpack-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-16%2F</url>
    <content type="text"><![CDATA[在之前的章节中，我们学到了有关于在配置环境中，如何区分开发环境与生产环境。但在源代码中还是不能区分开发环境与生产环境。事实上，我们经常会碰到开发环境中使用这个域名： http://test.api.com。正式环境中使用另一个域名：http://prod.api.com。所以，webpack提供了DefinePlugin插件。 DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 DefinePlugin 的用处，设置它，就可以忘记开发环境和生产环境构建的规则。 ¶1.安装 DefinePlugin是webpack的插件。所以我们需要安装webpack，如果前面安装过则无需安装。 1npm install --save-dev webpack ¶2.修改配置文件 修改webpack.dev.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 开发环境配置 * */const path = require('path');const webpack = require('webpack');- const merge = require('webpack-merge'); - const commonConfig = require('./webpack.common.js');// 开发环境的配置 const devConfig = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', devServer: &#123; contentBase: path.join(__dirname, 'dist'), clientLogLevel: 'info', open: true, host: 'localhost', port: '9090', inline: true, proxy: &#123; '/': &#123; target: 'http://yagmblog.com/', &#125;, '/upload': &#123; target: 'http://yagmblog.com' &#125; &#125;, hot: true, hotOnly: true, &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125; ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), ], output:&#123; filename: '[name].js', chunkFilename: '[name].chunk.js', &#125;, &#125;- module.exports = merge(commonConfig, devConfig) // 原来是在不同环境配置文件中导入公共的配置，在不同环境合并导出+ module.exports = devConfig; // 现在将不同环境的配置导入到公共配置中，根据打包命令传过来的环境参数进行不同的合并导出 修改webpack.prod.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 生产环境配置**/- const merge = require('webpack-merge');- const commonConfig = require('./webpack.common.js');// MiniCssExtractPlugin 代码分割插件，不支持热更新，在开发环境中使用影响开发效率，建议在生产环境中用// css 和 sass loader 使用 MiniCssExtractPlugin.loader const MiniCssExtractPlugin = require('mini-css-extract-plugin');// optimize-css-assets-webpack-plugin css压缩插件const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');const prodConfig = &#123; mode: 'production', devtool: 'cheap-module-souce-map', module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125; ], &#125;, optimization: &#123; minimizer: [ new OptimizeCssAssetsPlugin(&#123;&#125;) ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[name].chunk.css' &#125;), ], output: &#123; filename: '[name].[contenthash].js', chunkFilename: '[name].[contenthash].js' &#125;,&#125;- module.exports = merge(commonConfig, prodConfig) // 原来是在不同环境配置文件中导入公共的配置，在不同环境合并导出+ module.exports = prodConfig; package.json 12345678..."scripts": &#123; "dev": "webpack --mode development --env development --colors",+ "dev-build": "webpack --colors --config ./build/webpack.common.js --env=development", // 执行打包的入口文件则统一为`webpack.common.js`，下面同+ "start": "webpack-dev-server --colors --config ./build/webpack.common.js",+ "build": "webpack --colors --config ./build/webpack.common.js --env=production" //这块原来是生产环境的打包命令。现在加上`env`参数，方便在webpack.common.js文件中区分执行哪个配置 &#125;,... 在webpack.common.js的同级目录，新建webpack.config.js文件 webpack.config.js 123456789101112131415161718+ /**+ * process为node变量, argv为打包命令后面的所有参数，以数组形式排列。这里取env设置全局变量+ */+ + let regStr = /--env=/+ let argv = process.argv;+ let env = '';+ argv.forEach(val =&gt; &#123;+ if(regStr.test(val))&#123;+ env = val.replace(/--env=(.+)/g,"$1");+ &#125;+ &#125;)+ + let config = &#123; // 新建config变量，并将打包命令的env参数赋值给config。 tip: 此时的config依然在项目源码中无法使用+ NODE_ENV: env+ &#125;+ + module.exports = config 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 公共的配置文件**/const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const webpack = require('webpack');+ const config = require('./webpack.config.js'); // 引入config+ const merge = require('webpack-merge');+ const devConfig = require('./webpack.dev.js');+ const prodConfig = require('./webpack.prod.js');const commonConfig = &#123; entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.js$/, exclude: /(node_modules|bower_components|lib)/, loader: 'babel-loader' &#125;,&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), new webpack.ProvidePlugin(&#123; $: 'jquery', &#125;),+ new webpack.DefinePlugin(&#123; // 创建 peocess.env 全局常量，将webpack.config.js中的取到的环境变量赋值给peocess.env + 'process_env': JSON.stringify(config)+ &#125;) ], optimization: &#123; runtimeChunk: &#123; name: 'runtime', &#125;, usedExports: true, splitChunks: &#123; chunks: 'all', cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: -10, name: 'vendors', &#125; &#125; &#125; &#125;, performance: false, output: &#123; // publicPath: '../', filename: '[name].js', chunkFilename: '[name].chunk.js', path: path.resolve(__dirname, '../dist') &#125;&#125;- module.exports = commonConfig+ module.exports = env =&gt; &#123; // 这里的`env`则是`package.json`中的打包命令设置的env参数。这里可以通过函数参数的形式接收。+ if(env &amp;&amp; env.production)&#123; // 如果`env.production`存在。则使用生产环境配置文件。否则，使用开发环境配置文件+ return merge(commonConfig, prodConfig) + &#125;else &#123;+ return merge(commonConfig, devConfig)+ &#125;+ &#125; index.js 12345678910111213141516171819import _ from 'lodash';import $ from 'jquery'+ let host;+ + if(process_env.NODE_ENV == 'development')&#123; // 配置开发环境接口域名+ host = 'http://test.api.com'; + + &#125;else if(process_env.NODE_ENV == 'production')&#123; // 配置生产环境接口域名+ host = 'http://prod.api.com';+ &#125;+ console.log('--------');+ console.log(host); // 控制台打印设置的环境变量+ console.log('--------');const dom = $('&lt;div&gt;');dom.html(_.join(['蔓', '羊'], '-----'));$('body').append(dom); 修改完成，运行生产环境打包命令： npm run build 上面可以看到，控制台已经成功地打印出了 http://prod.api.com。 再重新运行开发环境打包命令： npm run dev-build 上面可以看到，控制台已经成功地打印出了 http://test.api.com。现在就成功实现项目源码中不同环境做不同的操作 ¶3. cross-env 运行跨平台设置和使用环境变量的脚本 cross-env是用来解决windows和Unix不同命令设置环境变量的问题。cross-env可以方便我们使用单一的命令来设置环境变量。让我们能够以unix方式设置环境变量，然后在windows上也能兼容运行。 安装 cross-env 1npm install --save-dev cross-env 修改 package.json 123456"scripts": &#123; "dev": "webpack --mode development --env development --colors",+ "dev-build": "cross-env NODE_ENV=test webpack --colors --config ./build/webpack.common.js", "start": "webpack-dev-server --colors --config ./build/webpack.common.js",+ "build": "cross-env NODE_ENV=prod webpack --colors --config ./build/webpack.common.js" &#125;, webpack.config.js 12345678910111213141516171819/** * process为node变量, argv为打包命令后面的所有参数，以数组形式排列。这里取env设置全局变量 */let regStr = /--env=/let argv = process.argv;let env = '';argv.forEach(val =&gt; &#123; if(regStr.test(val))&#123; env = val.replace(/--env=(.+)/g,"$1"); &#125;&#125;)let config = &#123; NODE_ENV: env,+ ENV: process.env.NODE_ENV,&#125;module.exports = config webpack.common.js 123456789101112131415161718192021222324252627...plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), new webpack.ProvidePlugin(&#123; $: 'jquery', &#125;), new webpack.DefinePlugin(&#123; 'process_env': JSON.stringify(config),+ 'process.env': JSON.stringify(config.ENV) &#125;) ], ...module.exports = env =&gt; &#123;+ if(process.env.NODE_ENV == 'prod')&#123; return merge(commonConfig, prodConfig) &#125;else &#123; return merge(commonConfig, devConfig) &#125;&#125; index.js 1234567891011121314151617181920import _ from 'lodash';import $ from 'jquery'let host;if(process_env.NODE_ENV == 'development')&#123; // 配置开发环境接口域名 host = 'http://test.api.com'; &#125;else if(process_env.NODE_ENV == 'production')&#123; // 配置生产环境接口域名 host = 'http://prod.api.com';&#125;+ console.log('--------');+ console.log(process.env); // 源码中控制台打印环境变量+ console.log('--------');const dom = $('&lt;div&gt;');dom.html(_.join(['蔓', '羊'], '-----'));$('body').append(dom); 运行 npm run build 生产环境打包命令，打包完成浏览器打开控制台 可以看到环境变量prod已经在控制台打印出来了。但在具体项目中，我们还是会使用不同环境调用不同的配置文件打包。所以了解了如何配置环境变量，最后代码回滚到这篇文章最开始状态。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-shimming-15]]></title>
    <url>%2F2019%2F08%2F07%2Fwebpack-shimming-15%2F</url>
    <content type="text"><![CDATA[shimming翻译过来就是垫片。我们之前的代码项目中，会在main.js中引入很多类似于下面的： 123import $ from 'jquery'import _ from 'loadsh'import &#123;http&#125; from 'util/http' 并且每个库只在当前引入的js文件中生效。如果我们同时在多个js文件中使用，那么需要在每个js文件中去import。所webpack提供了一个ProvidePlugin插件来帮我们第三方模块的全局引入。 ¶安装 webpack ProvidePlugin 文档 . 之前安装过就不需要安装了。没有安装的， 用下面的命令进行安装 1npm install --save-dev webpack 先来看下目录结构 123456789101112131415161718192021222324252627282930|- build |- webpack.common.js |- webpack.dev.js |- webpack.prod.js|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js+ |- test.js|- index.html|- package.json|- package-lock.json|- .babelrc test.js 写一个方法并导出，实现给body添加背景色 123+ export function ui()&#123;+ $('body').css('background', 'pink');+ &#125; index.js 123456789+ import _ from 'lodash';+ import $ from 'jquery' + import &#123; ui &#125; from './test.js' // 引入test.js文件+ + ui(); // 执行ui方法+ + const dom = $('&lt;div&gt;');+ dom.html(_.join(['dell', 'lee'], '-----'));+ $('body').append(dom); 现在运行 npm run start 可以看到报$找不到。并且我们之前也安装过jquery。为什么会报错呢？我们把index.js中的ui.js注释掉，在刷新页面，就会看到index.js中使用$创建的dom已经在页面上显示出来了。说明$是可以用的。也就是说，是test.js中的$找不到。index.js中明明引入了，为什么会找不到呢？ 这里需要解释下，我们一般在文件中引入的第三方库，它的this指向的则是当前的库，即只能在当前文件中使用。这也就是为什么在test.js中找不到$的原因了。那么我们想要引入一次，在项目的所有的文件都可以用，怎么做呢？ webpack的插件ProvidePlugin就是为我们解决这个问题的。 webpack.common.js 1234567891011121314...plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(),+ new webpack.ProvidePlugin(&#123; // 设置全局的变量+ $: 'jquery', // 在文件中遇到`$`则替换成`jquery`来执行事件+ &#125;)], ... 断开刚才的启动的命令，重新运行 npm run start。当配置文件有改动时，需要重新启动一个服务 现在可以看到index.js中的dom已经挂载到页面上了。test.js中设置body设置背景色也已经设置成功了。 这就是ProvidePlugin的作用。这种不仅适用于网上流行的第三方库，我们自己写的公共文件也可以用这种方式设置，在全局使用。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack浏览器缓存-14]]></title>
    <url>%2F2019%2F08%2F06%2Fwebpack%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98-14%2F</url>
    <content type="text"><![CDATA[我们在项目中通常会引入非常多的插件库。我们在修改业务逻辑时，需要重新打包。这样我们每更新一次。用户在使用都需要全部加载所有的资源。事实上。我们引入的第三方的插件库，是不希望用户每次使用都进行加载的。那么webpack中就为我们解决了这个问题。 ¶处理缓存配置 index.js 没有安装的我们先进行安装下。 12npm install lodash -Dnpm install i jquery 123456+ import _ from 'lodash';+ import $ from 'jquery'+ + const dom = $('&lt;div&gt;');+ dom.html(_.join(['dell', 'lee'], '-----'));+ $('body').append(dom); webpack.common.js 123456789101112131415161718optimization: &#123; usedExports: true, splitChunks: &#123; chunks: 'all',+ cacheGroups: &#123; // 添加库文件的打包配置+ vendors: &#123; + test: /[\\/]node_modules[\\/]/, // 匹配库文件+ priority: -10, // 优先级+ name: 'vendors', // 名字默认为 vendors~main.chunk.js。 这里配置为 vendors.chunk.js+ &#125;+ &#125; &#125; &#125;, output: &#123;- filename: '[name].js',- chunkFilename: '[name].chunk.js', path: path.resolve(__dirname, '../dist') &#125; webpack.dev.js 12345678910plugins: [ new webpack.HotModuleReplacementPlugin(), // new webpack.DefinePlugin(&#123; // 'process.env.NODE_ENV': JSON.stringify('development') // &#125;)],+ output:&#123; // 开发环境的输出配置+ filename: '[name].js', // 输出文件名的配置+ chunkFilename: '[name].chunk.js', // 输出的库文件的文件打包名配置+ &#125;, webpack.prod.js 12345678910plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[name].chunk.css' &#125;),],+ output: &#123; // 生产环境的输出配置+ filename: '[name].[contenthash].js', // 输出文件名的配置+ chunkFilename: '[name].[contenthash].js', // 输出的库文件的文件名打包配置+ &#125;, 生产环境打包 npm run build 现在我们看到已经打包好了带有contenthash的文件。main开头的是我们的自己写的业务逻辑。vendors的文件就是我们的库文件了。后续打包库文件正常名字是不会变的。当业务逻辑改变时，只有main开头的打包文件hash会变。很好的帮我们处理了文件缓存的问题。 库文件后续打包名字及hash值不会变，这个暂时只有webpack新版本会支持(我用的是webpack v4.32.2 。4.0以上的版本应该都是可以的)。在低版本中不会生效。低版本webpack打包的逻辑是，当业务逻辑文件和库文件之间是有联系的。所以当业务逻辑改变时，重新打包生成的库文件hash值也会变。所以每次项目更新都会连库文件一起更新。webpack提供了一个配置项，把库文件业务逻辑之间的关系抽离出成为一个单独的文件。这样就可以解决库文件每次都要重新加载的问题。下面我们看下配置： ¶抽离映射关系文件 webpack.common.js 123456789101112131415161718...optimization: &#123;+ runtimeChunk: &#123; // webpack打包会有一个mainfest映射关系文件。 runtimeChunk文件则是将映射关系文件抽离出来。+ name: 'runtime',+ &#125;, usedExports: true, splitChunks: &#123; chunks: 'all', cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: -10, name: 'vendors', &#125; &#125; &#125; &#125;, ... 这样配合后， 重新打包 npm run build 可以看大多出了一个runtime.js文件 现在我们更改下index.js文件。 123456import _ from 'lodash';import $ from 'jquery'const dom = $('&lt;div&gt;');+ dom.html(_.join(['dell', 'lee'], '++')); // 将连接符改成 ++$('body').append(dom); 这样配合后， 重新打包 npm run build 对比上面打包截图，可以看到runtime.js vendors.js文件的hash值都没变。只有main.js的hash值变了。 这样用户在加载页面时，就可以只加载main.js文件。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-css文件的代码分割-13]]></title>
    <url>%2F2019%2F07%2F17%2Fwebpack-css%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2-13%2F</url>
    <content type="text"><![CDATA[在开发中，当css文件非常大的时候，一般会把css文件提取出来。（ps：默认是打包在js中的）；那么webpack怎么提取css呢，请往下看。 mini-css-extract-plugin // css提取 optimize-css-assets-webpack-plugin // css压缩 ¶安装 mini-css-extract-plugin 1npm install --save-dev mini-css-extract-plugin 此插件是将原来打包在js文件中的css提取出来成为一个单独的css文件。目前不支持热重载（HMR）.在开发环境中使用会降低开发效率，建议在生产环境中使用。 webpack.dev.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * 开发环境配置 * */const path = require('path');const webpack = require('webpack');const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js');// 开发环境的配置 const devConfig = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', devServer: &#123; contentBase: path.join(__dirname, 'dist'), clientLogLevel: 'info', open: true, host: 'localhost', port: '9090', inline: true, proxy: &#123; '/': &#123; target: 'http://yagmblog.com/', &#125;, '/upload': &#123; target: 'http://yagmblog.com' &#125; &#125;, hot: true, hotOnly: true, &#125;, module: &#123;+ rules: [+ &#123;+ test: /\.css$/,+ use: [+ "style-loader",+ "css-loader",+ 'postcss-loader',+ ],+ &#125;,&#123;+ test: /\.scss$/,+ use: [+ 'style-loader',+ &#123;+ loader: 'css-loader',+ options: &#123;+ importLoaders: 2,+ &#125;+ &#125;,+ 'sass-loader',+ 'postcss-loader',+ ]+ &#125;+ ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), // new webpack.DefinePlugin(&#123; // 'process.env.NODE_ENV': JSON.stringify('development') // &#125;) ], &#125;/** * 合并导出 基础公共配置以及开发环境的配置 **/module.exports = merge(commonConfig, devConfig); webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 生产环境配置**/const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');+ // MiniCssExtractPlugin 代码分割插件，不支持热更新，在开发环境中使用影响开发效率，建议在生产环境中用+ // css 和 sass loader 使用 MiniCssExtractPlugin.loader + const MiniCssExtractPlugin = require('mini-css-extract-plugin');const prodConfig = &#123; mode: 'production', devtool: 'cheap-module-souce-map', module: &#123;+ rules: [+ &#123;+ test: /\.css$/,+ use: [+ MiniCssExtractPlugin.loader, // 将原来的style-loader换成代码分割里面的loader+ "css-loader",+ 'postcss-loader',+ ],+ &#125;,&#123;+ test: /\.scss$/,+ use: [+ MiniCssExtractPlugin.loader, // 将原来的style-loader换成代码分割里面的loader+ &#123;+ loader: 'css-loader',+ options: &#123;+ importLoaders: 2,+ &#125;+ &#125;,+ 'sass-loader',+ 'postcss-loader',+ ]+ &#125;+ ], &#125;, plugins: [+ new MiniCssExtractPlugin(&#123;+ filename: '[name].css', // 配置打包文件名。生成的css文件直接在页面中引用，则会走`filename`的配置项+ chunkFilename: '[name].chunk.css' + &#125;), ],&#125;/** * 合并导出 生产环境的配置 **/module.exports = merge(commonConfig, prodConfig); weback.common.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 公共的配置文件**/const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; main: './src/index.js', &#125;, module: &#123;- rules: [- &#123;- test: /\.css$/,- use: [- "style-loader",- "css-loader",- 'postcss-loader',- ],- &#125;,&#123;- test: /\.scss$/,- use: [- 'style-loader',- &#123;- loader: 'css-loader',- options: &#123;- importLoaders: 2,- &#125;- &#125;,- 'sass-loader',- 'postcss-loader',- ]- &#125;,&#123; test: /\.js$/, exclude: /(node_modules|bower_components|lib)/, loader: 'babel-loader' &#125;,&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), ], optimization: &#123; usedExports: true, splitChunks: &#123; chunks: 'all', &#125; &#125;, output: &#123; // publicPath: '../', filename: '[name].js', chunkFilename: '[name].chunk.js', path: path.resolve(__dirname, '../dist') &#125;&#125; 上原来css，sass文件打包配置都在公共的webpack.common.js文件中。现在分别写在webpack.dev.js和webpack.prod.js文件中来。 新建 assets/css/index.css 文件 123456+ body &#123;+ background: #eee;+ &#125;+ div &#123;+ color: green;+ &#125; 在index.js文件中引入index.css 123+ import './assets/css/index.css'+ + console.log('hello world!'); 现在执行前面配置的生产环境的打包 npm run build 从上面可以看到，我们打包的样式已经生效，并且打包出单独的css文件。 ¶安装 optimize-css-assets-webpack-plugin，进行css文件压缩 optimize-css-assets-webpack-plugin 是css压缩插件。 安装 optimize-css-assets-webpack-plugin 1npm install --save-dev optimize-css-assets-webpack-plugin webpack.prod.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 生产环境配置**/const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');// MiniCssExtractPlugin 代码分割插件，不支持热更新，在开发环境中使用影响开发效率，建议在生产环境中用// css 和 sass loader 使用 MiniCssExtractPlugin.loader const MiniCssExtractPlugin = require('mini-css-extract-plugin');+ // optimize-css-assets-webpack-plugin css压缩插件+ const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');const prodConfig = &#123; mode: 'production', devtool: 'cheap-module-souce-map', module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125; ], &#125;,+ optimization: &#123; // 优化配置项+ minimizer: [+ new OptimizeCssAssetsPlugin(&#123;&#125;) // 使用压缩css插件+ ]+ &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[name].chunk.css' &#125;), ],&#125;/** * 合并导出 生产环境的配置 **/module.exports = merge(commonConfig, prodConfig); 重新打包生产环境的包 1npm run build 现在可以看到打包生成的css文件已经被压缩到了一行。说明配置生效了。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-Preloading,Prefetching-12]]></title>
    <url>%2F2019%2F07%2F16%2Fwebpack-Preloading-Prefetching-12%2F</url>
    <content type="text"><![CDATA[前两章写了代码分割，目的在于优化加载速度。但是，是依靠缓存来优化第二次页面打开的速度。那这篇文章我们就看下怎么可以让页面第一次就可以快速打开。 Preloading,Prefetching 预加载官方文档. ¶1. 先来看下一般的代码分析 webpack.config.js 文件进行修改。去掉之前的配置 1234567 ... optimization: &#123; splitChunks: &#123;+ chunks: 'async', &#125; &#125;, ... index.js是上篇的内容不变 12345+document.addEventListener('click', () =&gt; &#123;+ const element = document.createElement('div');+ element.innerHTML = "hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello +worldhello worldhello worldhello worldhello worldhello world";+ document.body.appendChild(element);+&#125;) 现在我们打包运行npm run dev-build，浏览器打开页面。打开控制台。按组合键 ctrl + shift + p ,输入 cov, 或者在切换窗口视图选择， 打开如下视图，可以看到index.js的未利用率有77.7%事实上还是有很大的优化空间的。 ¶2. 代码优化 先来看下目录 12345678910111213141516171819202122232425262728293031|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js- |- lodash.js+ |- click.js|- index.html|- package.json|- package-lock.json|- webpack.config.js|- webpack.dev.js|- webpack.prod.js|- webpack.common.js|- .babelrc click.js 123456+ function getComponent()&#123;+ const element = document.createElement('div');+ element.innerHTML = "hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello + worldhello worldhello worldhello worldhello worldhello world";+ document.body.appendChild(element);+ &#125;export default getComponent; index.js 12345+ document.addEventListener('click', function()&#123;+ import('./click.js').then((&#123;default: _&#125;) =&gt; &#123;+ _();+ &#125;)+ &#125;) 现在我们使用懒加载的方式，加载click.js(即在点击页面的时候再去加载click.js)。现在可以看到代码的未使用率下降到了72.2%。这种懒加载的方法看起来确实优化了不少。我们想下。这种即用即加载的方式，如果临时加载的文件比较大。是不是会导致我们的操作看起来反应时间比较久？这就是懒加载带来的弊端。所以prefeting 和 preloading 可以帮我们解决这个由于优化带来的问题。 ¶2. Prefetching 和 Preloading 加载 上面的方式能看到控制台network模块，再刷新浏览器，只会加载index.html,main.js文件。当我们在点击页面的时候才会加载0.js(0.js是webpack帮我们把click.js打包后的文件)。现在我们修改下代码，看下Prefetching的效果。 Prefetching index.js 12345document.addEventListener('click', () =&gt; &#123;+ import(/* webpackPrefetch: true */ './click').then((&#123; default: _ &#125;) =&gt; &#123; _(); &#125;)&#125;) 重新打包，在浏览器查看页面，打开控制台network，刷新页面可以看到浏览器在直接加载出来了0.js文件(其实不是直接加载，是在index.html,main.js加载完成后加载的)。当我们点击页面的时候，会发现network又重新被加载了一遍。其实不是重新加载了。是之前在页面加载完成后空闲时间加载了0.js。这个时候加载的资源是从缓存中取出。这就是/* webpackPrefetch: true */ Prefetching预加载既能不占首页加载资源时间，又不用在使用的时候才加载的原因。 总结：Preloading和Prefetching的用法相同。不过Preloading是让代码和主代码并行加载。所以不推荐。webpack官方在配置中chunks: 'async'写的是异步，是想让我们编写异步程序来提高代码的性能，缓存能够带来的代码提升非常有限，我们后面写代码程序应该重点关注代码利用率，提高代码利用率才是真正提高代码性能，如果页面代码暂时不用，就采用异步懒加载的形势，主代码加载完成后利用空闲时间来加载其他子代码。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-lazy-loading-11]]></title>
    <url>%2F2019%2F07%2F16%2Fwebpack-lazy-loading-11%2F</url>
    <content type="text"><![CDATA[懒加载(或者按需加载)，是一种很好的优化页面加载速度的一种方式。在大型项目中效果尤为明显。其实就是让项目中模块在需要的时候再去加载。(以往的方式都是在首页加载，经常会导致首页加载慢，或者加载不出来的情况)。 注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。 index.js 123456789101112131415+ // async await promise es7异步函数写法。+ // default: _ 将引入的lodash 默认为 _+ async function getComponent()&#123;+ const &#123; default: _ &#125; = await import(/* webpackChunkName: 'lodash' */ 'lodash');+ const element = document.createElement('div');+ element.innerHTML = _.join(['hello', 'world'], "--")+ return element+ &#125;+ + + document.addEventListener('click', () =&gt; &#123;+ getComponent().then(element =&gt; &#123;+ document.body.appendChild(element);+ &#125;)+ &#125;) 运行npm run dev-build 1npm run dev-build 上面的代码的功能是，当在document上点击，执行getComponent()方法。在页面输出 hello--world。这里我们可以打开控制台刷新。切换到ALL模块。刷新页面，可以看到页面加载了 index,js，main.js文件。我们打包的lodash.js并没有加载。当随意点击页面上任何位置。可以看到lodash.js才会加载。这就是我们说的懒加载。在需要的时候才会加载。(我们熟悉的vue项目中的的路由就是利用import语法进行的懒加载的例子。)]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-Code-Spliting-10]]></title>
    <url>%2F2019%2F07%2F15%2Fwebpack-Code-Spliting-10%2F</url>
    <content type="text"><![CDATA[Code Spliting (代码分割)。是为了让我们的程序运行性能更高。和webpack无关。没有webpack，我们需要手动进行代码分割。但是在有了webpack之后，webpack可以帮我们做代码分割。 ¶1. 我们需要看下怎么进行手动代码分割，这里以lodash包为例 我们先安装下loadsh 1npm install lodash --save package.json修改，配置开发环境的打包命令 123456 "scripts": &#123; "dev": "webpack --mode development --env development --colors",+ "dev-build": "webpack --colors --config ./build/webpack.dev.js", "start": "webpack-dev-server --colors --config ./build/webpack.dev.js", "build": "webpack --colors --config ./build/webpack.prod.js" &#125; 修改index.js 1234+// 删除之前的代码+// 先引入lodash+import _ from "lodash"+console.log(_.join(['a', 'b', 'c'], '-')); 运行npm run dev-build 1npm run dev-build 可以看到打包的main.js文件是 577kb。我们的文件只写了两行，为什么打包文件会这么大呢。因为整个lodash库被打包到main.js文件中了。如果我们改了业务逻辑，那么在每次打开页面的时候都要加载这么大的main.js文件。这显然会导致用户体验非常不好。下面我们看下怎样优化。 ¶2. 优化手动代码分割 新建lodash.js文件，看下文件目录 12345678910111213141516171819202122232425262728293031|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js |- main.js+ |- lodash.js|- index.html|- package.json|- package-lock.json|- webpack.config.js|- webpack.dev.js|- webpack.prod.js|- webpack.common.js|- .babelrc lodash.js 12+import _ from "lodash" //将lodash全局引入+window._ = _; // 挂载到 window 上 index.js 12-import _ from "lodash"+console.log(_.join(['a', 'b', 'c'], '-')); webpack.common.js 这里我们需要添加lodash入口文件 123456...entry: &#123;+ lodash: './src/lodash.js', main: './src/index.js',&#125;... 运行npm run dev-build 1npm run dev-build 现在我们看到lodash已经被单独打包成一个文件了。main.js文件本身才28.8kb。我们知道浏览器是并行去加载文件的。现在我们就可以同时加载lodash，main文件。浏览器默认缓存静态文件。所以当修改过main.js文件时，再打开页面就只加载main.js文件就可以了。从优化上讲，可以在一定程度上加快加载速度。但是在webpack中，splitChunksPlugin可以帮我们做代码分割。下面我们看下。 ¶3. webpack同步代码分割 在配置之前，我们先将手动分割的代码删掉 删除lodash.js文件，看下文件目录 12345678910111213141516171819202122232425262728293031|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js |- main.js- |- lodash.js|- index.html|- package.json|- package-lock.json|- webpack.config.js|- webpack.dev.js|- webpack.prod.js|- webpack.common.js|- .babelrc webpack.common.js 删除lodash入口文件 123456...entry: &#123;- lodash: './src/lodash.js', main: './src/index.js',&#125;... 现在我们开始设置配置webpack代码分割 index.js 12+import _ from "lodash"+console.log(_.join(['a', 'b', 'c'], '-')); webpack.common.js 1234567891011121314...plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', template: './index.html', &#125;), new CleanWebpackPlugin(),],+optimization: &#123; //优化配置+ splitChunks: &#123; + chunks: "all" //代码分割基本配置+ &#125;+&#125;,... 重新打包。 可以看到webpack已经将引入的文件单独打包成一个文件，自动帮我们进行了代码分割。 ¶4. webpack异步代码分割 index.js 1234567891011+function getComponent()&#123;+ return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123;+ let element = document.createElement('div');+ element.innerHTML = _.join(['hello', 'world'], "-")++ return element+ &#125;)+&#125;+getComponent().then(element =&gt; &#123;+ document.body.appendChild(element);+&#125;) 安装动态引入组件语法转换插件 @babel/plugin-syntax-dynamic-import 1npm install @babel/plugin-syntax-dynamic-import --save-dev .babelrc 1234567891011121314151617181920212223242526272829&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "edge": "17", "firefox": "60", "safari": "11.1", "chrome": "67" &#125;, "useBuiltIns": "usage", &#125; ] ], "plugins": [ [ "@babel/plugin-transform-runtime", &#123; "absoluteRuntime": false, "corejs": 2, "helpers": true, "regenerator": true, "useESModules": false &#125; ],+ "@babel/plugin-syntax-dynamic-import", ]&#125; 打包 npm run dev-build 1npm run dev-build 现在我们在页面上可以看到异步我们连接的hello-world。异步引入lodash，并且不用写任何配置就可以直接打包。上图中的0.js就是我们打包出来的lodash库 ¶5. 代码分割修改文件名 我们看到上面webpack把分割的文件名自动命名成0.js。那么我们如果要自定义文件名怎么写呢？请往下看 修改 index.js 文件` 123456789101112function getComponent()&#123;+ /* webpackChunkName: 'lodash' */ 这种是 webpack 魔法注释的写法+ return import(/* webpackChunkName: 'lodash' */ 'lodash').then((&#123; default: _ &#125;) =&gt; &#123; let element = document.createElement('div'); element.innerHTML = _.join(['hello', 'world'], "-") return element &#125;)&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element);&#125;) 现在我们重新打包就可以看到文件名已经被改成vendors~lodash.js了。前面为什么有个vendors? 我们需要了解splitChunks的更多配置。 ¶6.splitChunks参数详解 参数 默认 说明 type chunks async 设置代码分割类型，和cacheGroups配合使用。async对异步代码分割。all对同步和异步代码分割。initial对同步代码进行分割 string minSize 30000(30kb) 当引入的模块大于30(kb)时才会做代码分割 number maxSize 0 当引入的模块大于maxSize时，会尝试对引入的模块进行二次拆分，一般使用默认配置即可。 number minChunks 1 当一个模块至少被引入1次，才会做代码分割；建议用默认配置。 number maxAsyncRequests 5 当引入5个以上的模块时，只会将前5个引入文件进行代码分割处理。 number maxInitialRequests 3 入口文件引入模块超过3个，只会将前3个进行代码分割。 number automaticNameDelimiter ~ 打包的组和文件名之间的连接符，比如上面的vendors~lodash.js string name true 拆分块的名称，使cacheGroups中的文件名设置生效 boolean cacheGroups {} 对符合拆分的代码进行一个分类打包设置 Object cacheGroups参数 参数 默认 说明 type priority 级别 当cacheGroups有多个分组时，如果分割的模块同时符合好几个分组，那那个分组的priority的值大，就按照哪个分组分割。 number filename vendors~mian。vendors 拆分的名称，一般不设置，默认生成vendorsmian。vendors分组名称，连接符，main引入模块的入口文件 String reuseExistingChunk true 如果当前块包含已从主束拆分的模块，则将重用它而不是生成新的块。比如import a from ‘A’``import b from ‘B’在打包时候，按照打包顺序也会将b打包进a模块，但是在a打包之前，如果已经将b模块进行过打包,那么就不会将b模块在打包到a模块中 boolean test /[\\/]node_modules[\\/]/ 控制此缓存组选择的模块。test:/[\/]node_modules[\/]/必须要在node_modules模块在才可以 function (module, chunk) enforce true 将对splitChunks.minSize,splitChunks.minChunks,splitChunks.maxAsyncRequests,splitChunks.maxInitialRequests配置忽略 boolean]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack development 和 production 模式的区分打包-9]]></title>
    <url>%2F2019%2F07%2F10%2Fwebpack-development-%E5%92%8C-production-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%86%E6%89%93%E5%8C%85-9%2F</url>
    <content type="text"><![CDATA[我们都知道，在项目中一般开发的时候需要一些特别的配置。上线生产环境同样需要一些只在生产环境的配置。但是怎么进行打包区分就是一个问题。下面我们看下如何区分开发和生产环境的打包。 ¶1. development 和 production 模式的区分打包 先来看文件结构 123456789101112131415161718192021222324252627282930|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js |- main.js|- index.html|- package.json|- package-lock.json-|- webpack.config.js+|- webpack.dev.js+|- webpack.prod.js+|- webpack.common.js|- .babelrc 原来的配置文件都在webpack.config.js中。文件中同时包括生产环境的配置和开发环境的配置。对于在不同环境的打包执行 多出了大量的冗余代码。现在我们将公共的配置提取到webpack.config.js中。对于开发环境配置写在webpack.dev.js中，开发环境的配置写在webpack.prod.js中。 webpack.dev.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 开发环境配置*/+ const path = require('path');+ const webpack = require('webpack');+ const merge = require('webpack-merge'); // 合并生产环境配置和公共配置+ const commonConfig = require('./webpack.common.js');+ + // 开发环境的配置+ const devConfig = &#123;+ mode: 'development',+ devtool: 'cheap-module-eval-souce-map',+ devServer: &#123;+ contentBase: path.join(__dirname, 'dist'),+ clientLogLevel: 'info',+ open: true,+ host: 'localhost',+ port: '9090',+ inline: true,+ proxy: &#123;+ '/': &#123;+ target: 'http://yagmblog.com/',+ &#125;,+ '/upload': &#123;+ target: 'http://yagmblog.com'+ &#125;+ &#125;,+ hot: true,+ hotOnly: true,+ &#125;,+ + plugins: [+ new webpack.HotModuleReplacementPlugin(),+ // new webpack.DefinePlugin(&#123;+ // 'process.env.NODE_ENV': JSON.stringify('development')+ // &#125;)+ ],+ optimization: &#123;+ usedExports: true,+ &#125;,+ + &#125;+ + + /** * 合并导出 基础公共配置以及开发环境的配置 **/+ module.exports = merge(commonConfig, devConfig); webpack.prod.js 12345678910111213141516/** * 生产环境配置**/+ const merge = require('webpack-merge'); // 合并开发环境配置和公共配置+ const commonConfig = require('./webpack.common.js'); + + + const prodConfig = &#123;+ mode: 'production',+ devtool: 'cheap-module-souce-map',+ &#125;+ /** * 合并导出 生产环境的配置 **/+ module.exports = merge(commonConfig, prodConfig); webpack.common.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 公共的配置文件**/+ const path = require('path');+ const HtmlWebpackPlugin = require('html-webpack-plugin');+ const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');+ + + module.exports = &#123;+ entry: &#123;+ main: './src/index.js',+ &#125;,+ module: &#123;+ rules: [&#123;+ test: /\.js$/, + exclude: /(node_modules|bower_components|lib)/,+ loader: 'babel-loader'+ &#125;,&#123;+ test: /\.jpg$/,+ use: [&#123;+ loader: 'url-loader',+ options: &#123;+ name: '[name].[ext]?[hash]',+ publicPath: './dist/img',+ outputPath: 'img',+ limit: 204800,+ &#125;+ &#125;+ ],+ &#125;,&#123;+ test: /\.css$/,+ use: [+ "style-loader",+ "css-loader",+ 'postcss-loader',+ + ],+ &#125;,&#123;+ test: /\.scss$/,+ use: [+ 'style-loader',+ &#123;+ loader: 'css-loader',+ options: &#123;+ importLoaders: 2,+ &#125;+ &#125;,+ 'sass-loader',+ 'postcss-loader',+ ]+ &#125;,&#123;+ test: /\.(eot|ttf|svg|woff|woff2)$/,+ use: [&#123;+ loader: 'file-loader',+ options: &#123;+ name: '[name].[ext]',+ publicPath: './iconfont',+ outputPath: 'iconfont',+ &#125;+ &#125;+ ],+ &#125;]+ &#125;,+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: 'mywebpack',+ // filename: 'bundle.html',+ template: './index.html',+ &#125;),+ new CleanWebpackPlugin(),+ ],+ output: &#123;+ // publicPath: '/', + filename: '[name].js',+ path: path.resolve(__dirname, 'dist')+ &#125;+ &#125; 重新配置打包不同环境的运行命令 package.json 12345678..."scripts": &#123; "dev": "webpack --mode development --env development --colors", "prod": "webpack --mode production --env production --colors",+ "start": "webpack-dev-server --colors --config webpack.dev.js", // 开发环境运行命令+ "build": "webpack --colors --config webpack.prod.js" // 生产环境运行命令&#125;,... 运行npm run build 1npm run build 运行完成在浏览器打开dist/main.js可以看到控制台打印出4(为什么打印出4上篇博客有写。)说明拆分配置成功。 一般项目中都会把配置文件放在根目录文件夹里，目录如下 123456789101112131415161718192021222324252627282930313233+|- build+ |- webpack.common.js+ |- webpack.dev.js+ |- webpack.prod.js|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js |- main.js|- index.html|- package.json|- package-lock.json-|- webpack.dev.js-|- webpack.prod.js-|- webpack.common.js|- .babelrc webpack.common.js 12345...output: &#123; filename: '[name].js',+ path: path.resolve(__dirname, '../', 'dist') // 这里的 __dirname 会指到build文件夹下面，所以打包的时候需要跳到上一层。这样打包的文件夹才会在根目录下面。&#125; 这里需要注意的是，package,json中的 CleanWebpackPlugin 插件我这里使用的 3.0.0 版本的。当dist目录改变的时候，CleanWebpackPlugin的清除路径也会随着打包路径的改变。不用我们手动去配置。但是在CleanWebpackPlugin 2.0版本以下。路径就需要我们去手动重新配置了。具体配置请网上自行搜索。 package.json这边相应的的文件目录也需要更改为./build/webpack.dev.js 12345678..."scripts": &#123; "dev": "webpack --mode development --env development --colors", "prod": "webpack --mode production --env production --colors",+ "start": "webpack-dev-server --colors --config ./build/webpack.dev.js", // 开发环境运行命令+ "build": "webpack --colors --config ./build/webpack.prod.js" // 生产环境运行命令&#125;,... 运行npm run build 1npm run build 打包完成后在浏览器打开dist/index.html.可以看到控制台会打印出4。 说明打包正常。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack Tree shaking-8]]></title>
    <url>%2F2019%2F07%2F10%2Fwebpack-Tree-shaking-8%2F</url>
    <content type="text"><![CDATA[Tree shaking 意思就是摇树。当我们在一个js文件中写入了多个导出方法时，但只引入了一部分方法。那么打包的时候 Tree shaking 就会帮我们自动打包引入的文件。其他没引入的方法进行打包 ¶1. Tree shaking 先来看文件结构 123456789101112131415161718192021222324252627|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js+ |- main.js|- index.html|- package.json|- package-lock.json|- webpack.config.js|- .babelrc src/main.js 1234567+export const add = (a, b) =&gt; &#123;+ console.log(a + b);+&#125;+export const minus = (a, b) =&gt; &#123;+ console.log(a - b);+&#125; src/index.js删除原来的代码 123+import &#123; add &#125; from "./main.js"++add(1, 2) 运行webpack, development模式打包 1npm run dev 打包完成后，打开dist/main.js 1234567891011/***/ "./src/main.js":/*!*********************!*\ !*** ./src/main.js ***! \*********************//*! exports provided: add, minus *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() &#123; return add; &#125;);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minus\", function() &#123; return minus; &#125;);\nconst add = (a, b) =&gt; &#123;\n console.log(a + b);\n&#125;;\nconst minus = (a, b) =&gt; &#123;\n console.log(a - b);\n&#125;;\n\n//# sourceURL=webpack:///./src/main.js?");/***/ &#125;) 我们可以看到 add minus 方法都打包进来了。但其实我们没用到minus。这样就使我们的打包文件变大了。下面我们看下使用 Tree shaking 怎么可以不打包没用的代码。 ¶2. Tree shaking开发环境(development)的配置 webpack.config.js 123456789...+optimization: &#123; // 对代码优化的配置+ usedExports: true, // 设置只对使用的方法进行打包。只在 development 环境下进行设置。production模式已经内置了 Tree shaking 帮我们处理代码 。+&#125;,output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist')&#125; package.js 1234567&#123; "name": "webpackdemo",+ "sideEffects": [ // Tree shaking 默认会对所有的文件进行处理打包。对于类似css这种没有导出的文件也会tree shaking。会被过滤掉。但事实是我们是需要这个文件的。所以需要我们在这里进行将css文件单独列出来，让它不被tree shaking处理。如果没有文件需要特殊处理。直接设置为false即可。+ ] "*.css"+ ],...&#125; 运行webpack, development模式打包 1npm run dev 打包完成后，打开dist/main.js 123456789101112/***/ "./src/main.js":/*!*********************!*\ !*** ./src/main.js ***! \*********************//*! exports provided: add, minus *//*! exports used: add *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() &#123; return add; &#125;);\n/* unused harmony export minus */\nconst add = (a, b) =&gt; &#123;\n console.log(a + b);\n&#125;;\nconst minus = (a, b) =&gt; &#123;\n console.log(a - b);\n&#125;;\n\n//# sourceURL=webpack:///./src/main.js?");/***/ &#125;) 我们可以看到 较配置之前的打包，注释多了行: exports used: add。这说明我们的配置生效了。但是在development模式下依然会帮我们把未使用的方法打包进来。development模式下删除未使用的方法不利于错误的行数定位。当模式为production线上生产环境。未使用的方法会自动帮我们删掉。放在这个代码中，就是帮我们删掉minus这个方法(ps: 不打包)。 ¶3. Tree shaking生产环境(production)的配置 webpack.config.js 123456789101112...+mode: 'production',- devtool: 'cheap-module-eval-souce-map',+ devtool: 'cheap-module-souce-map',-optimization: &#123; - usedExports: true, -&#125;,output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist')&#125; 现在我们运行webpack, production 模式 1npm run prod 现在我们看到在production打包的文件dist/main.js里面只有方法的add被打包进来。minus方法已经去掉了。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack处理ES6语法-7]]></title>
    <url>%2F2019%2F07%2F03%2Fwebpack%E5%A4%84%E7%90%86ES6%E8%AF%AD%E6%B3%95-7%2F</url>
    <content type="text"><![CDATA[我们知道，ES6语法目前是不能被大部分主流浏览器所识别的。我们项目中所用的框架都是帮我们做好了ES6转ES5。所以我们可以直接使用ES6。 那么我们自己去配置项目的时候语法怎么处理呢。下面我们就来看下语法转换。 babel官网 ¶1.安装babel 1npm install --save-dev babel-loader @babel/core webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const webpack = require('webpack');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', entry: &#123; main: './src/index.js', &#125;, devServer: &#123; contentBase: path.join(__dirname, 'dist'), clientLogLevel: 'info', open: true, host: 'localhost', port: '9090', inline: true, proxy: &#123; '/': &#123; target: 'http://yagmblog.com/', &#125;, '/upload': &#123; target: 'http://yagmblog.com' &#125; &#125;, hot: true, hotOnly: true, &#125;, module: &#123; rules: [&#123;+ test: /\.js$/, + exclude: /(node_modules|bower_components|lib)/,+ loader: 'babel-loader' &#125;,&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), new webpack.HotModuleReplacementPlugin() ], output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 文件结构 123456789101112131415161718192021222324252627|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js|- index.html|- package.json|- package-lock.json|- webpack.config.js+ |- .babelrc 安装@babel/preset-env 1npm install @babel/preset-env --save-dev .babelrc 123+&#123;+ "presets": ["@babel/preset-env"]+&#125; index.js 12345678const arr = [ new Promise(() =&gt; &#123;&#125;), new Promise(() =&gt; &#123;&#125;)]arr.map(val =&gt; &#123; console.log(val);&#125;) package.json 12345"scripts": &#123;+ "dev": "webpack --mode development --env development --colors", "prod": "webpack --mode production --env production --colors", "start": "webpack-dev-server --colors" &#125;, 执行我们开发环境的打包 1npm run dev 打包完成后我们能看到dist目录下面的main.js, 最下面我们可以找到下面的这段代码(也可以直接搜索index.js)。 const被编译成var，箭头语法也被编译成function。已经实现了ES6到ES5的转换。但这只转换了一部分。在一些低版本浏览器中promise和map依然识别不了。 123456789101112/***/ "./src/index.js":/*!**********************!*\ !*** ./src/index.js ***! \**********************//*! no static exports found *//***/ (function(module, exports) &#123;eval("// import \"./assets/css/index.css\"\nvar arr = [new Promise(function () &#123;&#125;), new Promise(function () &#123;&#125;)];\narr.map(function (val) &#123;\n console.log(val);\n&#125;);\n\n//# sourceURL=webpack:///./src/index.js?");/***/ &#125;)/******/ &#125;); ¶2.兼容低版本浏览器 安装@babel/polyfill 1npm install --save @babel/polyfill index.js 12345678910+import "@babel/polyfill"const arr = [ new Promise(() =&gt; &#123;&#125;), new Promise(() =&gt; &#123;&#125;)]arr.map(val =&gt; &#123; console.log(val);&#125;) 执行我们开发环境的打包 1npm run dev 1234567891011/***/ "./node_modules/@babel/polyfill/lib/index.js":/*!***************************************************!*\ !*** ./node_modules/@babel/polyfill/lib/index.js ***! \***************************************************//*! no static exports found *//***/ (function(module, exports, __webpack_require__) &#123;"use strict";eval("\n\n__webpack_require__(/*! ./noConflict */ \"./node_modules/@babel/polyfill/lib/noConflict.js\");\n\nvar _global = _interopRequireDefault(__webpack_require__(/*! core-js/library/fn/global */ \"./node_modules/core-js/library/fn/global.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;\n\nif (_global.default._babelPolyfill &amp;&amp; typeof console !== \"undefined\" &amp;&amp; console.warn) &#123;\n console.warn(\"@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended \" + \"and may have consequences if different versions of the polyfills are applied sequentially. \" + \"If you do need to load the polyfill more than once, use @babel/polyfill/noConflict \" + \"instead to bypass the warning.\");\n&#125;\n\n_global.default._babelPolyfill = true;\n\n//# sourceURL=webpack:///./node_modules/@babel/polyfill/lib/index.js?");/***/ &#125;), 从打包的main.js中可以看到，Promise和map方法 @babel/polyfill 已经帮我们做了实现，但是打包文件突然增大到400多kb。是因为main.js文件将整个 polyfill都打包进来。但是我们想要的是我们在index.js文件用到的方法帮我们做打包处理，没用到的方法就不需要打包进main.js ¶3.现在我们配置让它只打包我们用到的方法 .babelrc 1234567891011&#123; "presets": [ [ "@babel/preset-env",+ &#123;+ "useBuiltIns": "usage",+ &#125; ] ] &#125; 执行我们开发环境的打包 1npm run dev 当我们配置了.babelrc的 “useBuiltIns”: “usage” 再次打包,发现我们的打包文件已经到90多kb了。“useBuiltIns”: &quot;usage&quot;的特性就是当polyfill低版本的浏览器添加一些特性的时候，不是把所有的特性都加进去。而是我们用到什么才去添加什么。 ¶4.设置浏览器版本 .babelrc 12345678910111213141516&#123; "presets": [ [ "@babel/preset-env", &#123;+ "targets": &#123;+ "edge": "17",+ "firefox": "60",+ "safari": "11.1",+ "chrome": "67"+ &#125;, "useBuiltIns": "usage", &#125; ] ]&#125; “chrome”: “67” 指编译的代码要运行在67版本的chrome浏览器上， 如果chrome67版本的chrome支持promise语法，则不转换，否则就转换。 执行我们开发环境的打包 1npm run dev ¶5.插件开发 平时开发直接引入就可以用了。但如果是开发插件，上面那种promise 全局引入会污染全局环境。下面用插件安装的方式来引入 安装pluginTransformRuntime 123npm install --save-dev @babel/plugin-transform-runtimenpm install --save-dev @babel/runtimenpm install --save-dev @babel/runtime-corejs2 babelrc 12345678910111213141516171819202122232425262728&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "edge": "17", "firefox": "60", "safari": "11.1", "chrome": "67" &#125;, "useBuiltIns": "usage", &#125; ] ],+ "plugins": [+ [+ "@babel/plugin-transform-runtime",+ &#123;+ "absoluteRuntime": false,+ "corejs": 2,+ "helpers": true,+ "regenerator": true,+ "useESModules": false+ &#125;+ ]+ ]&#125; 执行我们开发环境的打包 1npm run dev 打包完成之后，可以看到 promise和map依然会帮我们进行处理。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-devServer开发配置-6]]></title>
    <url>%2F2019%2F06%2F28%2Fwebpack-devServer%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE-6%2F</url>
    <content type="text"><![CDATA[webpack-dev-server是一个快速搭建本地运行环境的工具，实际开发中我们需要请求接口调用数据。在我们以前的打包文件中，直接在浏览器打开是file协议，而file是无法调取接口的，webpack-dev-server可以帮我们将file协议改成http协议。 webpack-dev-server 实现以下功能： 自动打开浏览器 调试接口 实时刷新 热更新 使用代理 ¶1.安装 webpack-dev-server 插件 (自动打开浏览器 | 调试接口 | 实时刷新 | 使用代理) 1npm install webpack-dev-server -D webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', entry: &#123; main: './src/index.js', &#125;,+ devServer: &#123; //添加devServer配置+ contentBase: path.join(__dirname, 'dist'), // 设置文件的根目录+ clientLogLevel: 'info', // 在开发工具(DevTools)的控制台(console)将显示消息，如：在重新加载之前，在一个错误之前，或者模块热替换(Hot Module Replacement)启用+ open: true, // 编译完成后自动帮我们打开默认浏览器+ host: 'localhost', // 默认为localhost, 如果在局域网内想让别人也可以访问，可以设置成你的本机地址，比如：192.168.0.120+ port: '9090', // 页面访问的端口+ inline: true, // 实时更新+ proxy: &#123; //设置代理+ '/api': &#123; // 如果请求到 /api/users , 现在会被代理到请求 http://yagmblog.com/api/users , /api会被target替换。如果不想始终传递 /api, 则需要重写路径。 + target: 'http://yagmblog.com/',+ pathRewrite: &#123; //重写路径+ '/api': ''+ &#125;+ &#125;,+ '/upload': &#123; //配置图片上传代理+ target: 'http://yagmblog.com'+ &#125;+ &#125;,+ &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), ], output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; package.json 12345678910111213141516171819202122232425262728293031323334&#123; "name": "webpackdemo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "dev": "webpack --mode development --env development --watch --colors --progress", "prod": "webpack --mode production --env production --colors --progress",+ "start": "webpack-dev-server --colors --progress", //配置本地开发运行命令 --colors 对编译提示信息添加颜色，--progress显示编译进度 "server": "node server.js " &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "autoprefixer": "^9.5.1", "clean-webpack-plugin": "^3.0.0", "css-loader": "^2.1.1", "express": "^4.17.1", "extract-text-webpack-plugin": "^4.0.0-beta.0", "file-loader": "^3.0.1", "html-webpack-plugin": "^3.2.0", "node-sass": "^4.12.0", "postcss-loader": "^3.0.0", "sass-loader": "^7.1.0", "style-loader": "^0.23.1", "url-loader": "^1.1.2", "webpack": "^4.32.2", "webpack-cli": "^3.3.2", "webpack-dev-middleware": "^3.7.0", "webpack-dev-server": "^3.7.2" &#125;&#125; ¶2.模块热替换 HMR( HotModuleReplacementPlugin ) 现在我们将webpack.config.js进行修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');+ const webpack = require('webpack'); module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', entry: &#123; main: './src/index.js', &#125;, devServer: &#123; contentBase: path.join(__dirname, 'dist'), clientLogLevel: 'info', open: true, host: '192.168.0.129', port: '9090', inline: true, proxy: &#123; '/': &#123; target: 'http://yagmblog.com/', &#125;, '/upload': &#123; target: 'http://yagmblog.com' &#125; &#125;,+ hot: true, // 配置devServe的热更新+ hotOnly: true, // 如果更新失败，不做任何操作： 默认刷新 &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(),+ new webpack.HotModuleReplacementPlugin() // 热更新插件 ], output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;!-- 设置文档标题 --&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;+ &lt;div id="root"&gt;蔓羊博客&lt;/div&gt; &lt;span class="iconfont icon-changjingguanli"&gt;&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; index.js 1+ import "./assets/css/index.css" index.css 123+ div &#123;+ color: pink;+ &#125; 写好后，运行 1npm run start 现在浏览器页面上显示粉色的 蔓羊博客。现在打开index.css文件，将样式改成绿色,保存。： 123div &#123;+ color: green;&#125; 返回浏览器页面, 现在可以看到控制台doc里面没有请求，也就是没有刷新，但是字体已经变成绿色了.这就是 HotModuleReplacementPlugin 的作用。 在不刷新浏览器的情况下可以即时的更改css样式。对于前端写经常写样式的小伙伴来说。真的是非常方便了。但是对js文件就不起作用了。 ¶2.1 js模块热替换 现在我们在src下面和index.js目录同级新建一个test.js 文件 test.js 12345678+function add()&#123;+ var div = document.createElement('div');+ div.innerHTML = 'hello';+ div.setAttribute('id', 'add')+ document.body.appendChild(div);+&#125;+ export default add index.js 123456 import "./assets/css/index.css"+ import add from "./test.js";+ window.onload = function()&#123;+ add();+ &#125; 上面的代码想实现的是， 创建一个div并设置内容为hello, 然后挂载到body上 现在重新运行： 1npm run start 可以看到hello 已经显示在页面上了。 现在我们将test.js文件内容 hello 999修改为 hello world,保存文件。返回查看浏览器，这里注意，不要刷新浏览器。会发现我们页面上的hello并没有变 12345678function add()&#123; var div = document.createElement('div');+ div.innerHTML = 'hello world'; div.setAttribute('id', 'add') document.body.appendChild(div);&#125;export default add 修改index.js 123456789101112131415import "./assets/css/index.css"import add from "./test.js";window.onload = function()&#123; add();&#125;+if(module.hot)&#123; // 相当于监听+ module.hot.accept('./test.js', (() =&gt; &#123; // 当test.js文件有变动时，先移除原来的dom，在添加新的dom+ document.body.removeChild(document.getElementById('add'));+ add();++ &#125;))+&#125; 保存后刷新浏览器，我们看到现在页面上显示的是刚才修改过的hello world。现在我们修改test.js文件。将hello world修改成world。保存。返回查看浏览器不要刷新，这个时候页面上的内容已经变成world 。 12345678function add()&#123; var div = document.createElement('div');+ div.innerHTML = 'world'; div.setAttribute('id', 'add') document.body.appendChild(div);&#125;export default add 从上面可以知道。当我们使用热更新时，只有样式会被更新。js文件并不会更新。需要js更新，就需要手动编写module.hot。先进行dom移除再添加。但是我们在写项目的时候一般也不会写 module.hot。项目依然可以更新是为什么呢？ 这是由于我们写的项目所用的框架里面已经集成了热更新，比如：vue-loader, react-hot-loader 。所以一般不需要我们自己去写。但是原理我们要明白。其实css文件也不会更新。只不过css-loader里面帮我们集成了更新的功能。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包iconfont-5]]></title>
    <url>%2F2019%2F06%2F27%2Fwebpack%E6%89%93%E5%8C%85iconfont-5%2F</url>
    <content type="text"><![CDATA[在项目中，避免不了要使用字体图标文件。这里我们看下iconfont打包配置 阿里巴巴矢量图标 将下载的iconfont文件放入src/assets/下面的iconfont文件夹下 开始之前，为了文件结构清晰，我们将js, css, scss, iconfont文件统一放入assets文件夹，目录如下： 1234567891011121314151617181920212223242526|- dist|- node-modules|- src+ |- assets+ |- images+ | |- 1.jpg+ |- css + | |- index.css + |- scss + | |- index.scss + |- iconfont+ |- demo_index.html+ |- demo.css+ |- iconfont.css+ |- iconfont.eot+ |- iconfont.svg+ |- iconfont.js+ |- iconfont.ttf+ |- iconfont.woff+ |- iconfont.woff2+ |- index.js|- index.html|- package.json|- package-lock.json|- webpack.config.js index.js 做以下改动 123456789101112131415161718192021+import yimg from "./assets/images/1.jpg" //更改引入目录+import test from "./assets/css/index.css" //更改引入目录+import avatar from "./assets/sass/index.scss" //更改引入目录+import "./assets/iconfont/iconfont.css" //引入iconfont.css文件window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; //var image = new Image(); //image.src = yimg; //image.classList.add('test'); //image.classList.add('img'); root.appendChild(dom); root.append(image);&#125; index.html 文件使用字体文件 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;!-- 设置文档标题 --&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt;+ &lt;span class="iconfont icon-changjingguanli"&gt;&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js中加入打包处理方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657module.exports = &#123; module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ 'style-loader', 'css-loader', 'postcss-loader', ] &#125;,&#123; test: /\.scss/, use: [ 'style-loader', 'css-loader', 'postcss-loader', &#125;,&#123; test: /\.scss/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoader: 2 &#125; &#125; 'scss-loader', 'postcss-loader', ]+ &#125;,&#123;+ test: /\.(eot|ttf|svg|woff|woff2)$/, //匹配iconfont文件+ use: [+ &#123;+ loader: 'file-loader', //使用file-loader处理+ options: &#123; //配置项+ name: '[name].[ext]', // 打包生成的文件名字+ publicPath: './iconfont', //打包完成后index.html引入的iconfont的路径+ outputPath: 'iconfont', // 打包完成后dist下面放iconfont文件的文件夹+ &#125;+ &#125;+ ],+ &#125;] &#125;, plugins: [], &#125; 运行打包命令 npm run dev , 可以看到iconfont被成功引入到页面中：]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack便捷打包配置-4]]></title>
    <url>%2F2019%2F06%2F27%2Fwebpack%E4%BE%BF%E6%8D%B7%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE-4%2F</url>
    <content type="text"><![CDATA[html-webpack-plugin clean-webpack-plugin 前面我们打开文件一直用的自己写的入口文件 index.html 。在实际的开发生产过程中。需要把入口文件以及打包后的文件上传到服务器。这样我们每次都要把index.html文件放在打包文件夹里面，并且一个个去引入生成的js及css文件(ps:生成的文件名一般都带有hash值，来保证页面上引入的文件是最新的打包文件)这样会很麻烦。其实是有插件来帮我们做这些事情的。 html-webpack-plugin 为打包的文件生成一个入口的html文件。默认index.html ¶1. html-webpack-plugin 插件 1+ npm install --save-dev html-webpack-plugin webpack.config.js文件 123456789101112+ const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; module: &#123;&#125;,+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: 'mywebpackdemo', //设置文档标题+ filename: 'index.html', //设置生成html文件的名字+ template: './index.html' // 如果想要生成的文件是你自己写的，就把你写的文件路径写在这，作为模板。这里我将根目录下的index.html作为模板+ &#125;)+ ], &#125; index.html文件 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;!-- 设置文档标题 --&gt;+ &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; - &lt;script src="./dist/main.js"&gt;&lt;/script&gt; //去掉前面手动引入的文件&lt;/body&gt;&lt;/html&gt; 现在打开命令行终端, 输入 打包命令： npm run dev 1npm run dev 打包完成后，在浏览器打开dist下面的index.html文件，可以看到生成的index.html已经自动为我们引入了main.js文件 ¶1. clean-webpack-plugin 插件 clean-webpack-plugin 一个清除文件的插件。 可以帮我们每次打包时，自动帮我们清除dist目录下面的原来的打包文件。 安装 1npm install --save-dev clean-webpack-plugin webpack.config.js文件 12345678910111213141516 const HtmlWebpackPlugin = require('html-webpack-plugin');+ const &#123; CleanWabpckPlugin &#125; = require('clean-webpack-plugin'); //这里要注意下，这是webpack v4.32.1版本以上(包括v4.32.1) , CleanWabpckPlugin的引入方式。如引入错误，会提示 CleanWebpackPlugin is not a constructor+ const CleanWebpackPlugin = require('clean-webpack-plugin'); // 这是webpack v4.32.1版本以下的 引入方式。 module.exports = &#123; module: &#123;&#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpackdemo', //设置文档标题 filename: 'index.html', //设置生成html文件的名字 template: './index.html' // 如果想要生成的文件是你自己写的，就把你写的文件路径写在这，作为模板。这里我将根目录下的index.html作为模板 &#125;),+ new CleanWebpackPlugin(), ], &#125; 为了说明CleanWebpackPlugin 的作用，可以在dist里面多建几个文件 然后打开命令行终端, 输入 打包命令： npm run dev 1npm run dev 打包完成后，可以看看刚才新建的文件是否都被删除了。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack样式打包-3]]></title>
    <url>%2F2019%2F06%2F04%2Fwebpack%E6%A0%B7%E5%BC%8F%E6%89%93%E5%8C%85-3%2F</url>
    <content type="text"><![CDATA[这篇的重点： style-loader css-loader sass-loader postcss-loader 添加厂商前缀 写前端项目时，少不了写样式。这篇就看看css打包是如何配置的 ¶1.loader的执行顺序：从下到上，从右到左 12345678910&#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader',+ 'sass-loader',+ 'less-loader',+ 'postcss-loader',+ ]+ &#125; ¶2.css打包 先来看下项目结构, 新建css文件以及index.css文件。我们需要的效果是将图片变小，并且偏移： 123456789101112webpackdemo|- dist|- node-modules|- src |- images | |- 1.jpg+ |- css + | |- index.css //添加的样式文件|- index.html|- index.js|- package.json|- package-lock.json index.css 12345+.test &#123;+ width: 200px;+ height: 200px;+ transform: translate(100px, 100px);+&#125; index.js 12345678910111213141516import yimg from "./images/1.jpg"+import index from "./css/index.css" // index.js引入样式文件window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; var image = new Image(); image.src = yimg;+ image.classList.add('test'); // 这里的test是index.css里面的类名 root.appendChild(dom); root.append(image);&#125; 修改webpack配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ],+ &#125;,&#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader',+ ]+ &#125;] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 安装style-loader css-loader css-loader可以识别并打包css文件。style-loader 是将处理的样式挂载到页面上 文档移步这里： style-loader css-loader。 1npm install style-loader css-loader --save-dev 安装完成后，执行： 1npm run dev 浏览器打开index.html就可以看到css已经有效果了 ¶3.scss打包 效果是将scss文件进行编译打包，是图片顺时针转70度，修改文件目录结构，添加sass文件夹以及index.scss文件 1234567891011121314webpackdemo|- dist|- node-modules|- src |- images | |- 1.jpg |- css | |- index.css + |- scss + | |- index.scss //添加的scss文件|- index.html|- index.js|- package.json|- package-lock.json index.scss 12345678+body &#123;+ .img &#123;+ margin-top: 300px;+ width: 200px;+ height: 200px;+ transform: rotate(70deg);+ &#125;+&#125; index.js 123456789101112131415161718import yimg from "./images/1.jpg"import index from "./css/index.css" +import avatar from "./sass/index.scss" //引入index.scss文件window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; var image = new Image(); image.src = yimg;+ //image.classList.add('test'); + image.classList.add('img'); //将img类赋值到src上面 root.appendChild(dom); root.append(image);&#125; 修改webpack配置 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ 'style-loader', 'css-loader', ]+ &#125;,&#123;+ test: /\.scss/,+ use: [+ 'style-loader',+ &#123;+ loader: 'css-loader', //css-loader+ options: &#123; + importLoader: 2 //当index.scss文件中有导入 @import b.scss 文件时，需要重新加载css-loader的前面的loader插件+ &#125;+ &#125;+ 'scss-loader' //将scss语法编译成css语法+ ]+ &#125; ] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 安装sass-loader sass-loader将scss文件转译成css文件以让浏览器识别。 文档移步这里： sass-loader 1npm install sass-loader node-sass --save-dev 安装完成后，执行： 1npm run dev 浏览器打开index.html就可以看到scss已经被成功的编译打包成css语法了 ¶4.postcss-loader 添加厂商前缀 一般写样式的时候，我们为了兼容主流浏览器，都会在css3的新属性前加上厂商前缀。当项目变的很大的时候，手动去写就变的非常麻烦了。那么postcss-loader就是帮助我们加自动的添加前缀的。 新建postcss.config.js 12345+module.exports = &#123;+ plugins: [+ require('autoprefixer')+ ]+ &#125; 修改webpack配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ 'style-loader', 'css-loader',+ 'postcss-loader', ] &#125;,&#123; test: /\.scss/, use: [ 'style-loader', 'css-loader',+ 'postcss-loader', &#125;,&#123; test: /\.scss/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoader: 2 &#125; &#125; 'scss-loader',+ 'postcss-loader', ] &#125; ] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 安装postcss-loader postcss-loader自动添加厂商前缀。 文档移步这里： postcss-loader 1npm i -D postcss-loader 安装 autoprefixer 插件 1npm install autoprefixer --save-dev 安装完成后，执行： 1npm run dev 浏览器打开index.html就可以看到transform前面已经自动加上了-webkit-]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack图片打包-2]]></title>
    <url>%2F2019%2F06%2F03%2Fwebpack%E5%9B%BE%E7%89%87%E6%89%93%E5%8C%85-2%2F</url>
    <content type="text"><![CDATA[webpack只认识js文件和JSON文件，所以打包的时候默认是会对这两种类型的文件进行打包。但实际的项目中，除了js和JSON，还有css， img等文件。 这些文件就需要依赖loader来进行编译然后才能被浏览器识别并渲染出来。loader就是文件打包的一种解决方案。 下面我们要认识的是： 图片打包 css打包 先来说图片打包，现在看下目录结构，新建images文件夹，随便下载一张图片放进去： 12345678910webpackdemo|- dist|- node-modules|- src+ |- images+ |- 1.jpg|- index.html|- index.js|- package.json|- package-lock.json 在index.js文件中添加如下内容，目的是将图片引入进来 index.js 12345678910111213+import yimg from "./images/1.jpg" //先将js引入进来window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; + var image = new Image(); //创建img标签+ image.src = yimg; // 将img的src属性设置成我们引入的图片 root.appendChild(dom);+ root.append(image);&#125; 由于webpack默认不认识以jpg/png 这些后缀名结尾的文件，所以要在webpack.config.js中配置loader。修改webpack.config.js文件， 这里处理图片文件用file-loader。 webpack.config.js 1234567891011121314151617181920212223242526var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;,+ module: &#123; //是配置我们的模块规则+ rules: [&#123; //rules里面可以配置各种文件处理的规则+ test: /\.jpg|png|jpeg|gif$/, //匹配以jpg|png|jpeg|gif结尾的文件+ use: [&#123; //使用的loader+ loader: 'file-loader', //这里用file-loader来处理图片+ options: &#123; //options里面可以配置详细的处理信息+ name: '[name].[ext]?[hash]', // 打包文件名+ publicPath: './dist/img', // 打包的公共路径(ps:默认是在output.path下面)+ outputPath: 'img', // 打包的文件放在img文件夹内。比如默认打包出来是在 dist/1.img。设置outpurpath就是dist/img/1.jpg+ &#125;+ &#125;,+ ]+ &#125;]+ &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; file-loader配置完成后，我们需要安装file-loader, npm install file-loader --save-dev 或者 npm install file-loader -D 都可以： 1npm install file-loader --save-dev 安装完成之后，就可以在命令行输入我们之前配置好的命令： 1npm run dev 这是打包完成目录及效果, 这个时候img被单独打包成一个文件： file-loader 打包的图片会被直接img引用，页面渲染的时候会发送请求。如果图片很小。页面中又有很多的时候时候，是很浪费下载通道的。 这个时候我们可以用url-loader。 url-loader: url-loader 功能类似于 file-loader，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。 现在我们改下配置： webpack.config.js 123456789101112131415161718192021222324252627var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; //是配置我们的模块规则 rules: [&#123; //rules里面可以配置各种文件处理的规则 test: /\.jpg|png|jpeg|gif$/, //匹配以jpg|png|jpeg|gif结尾的文件 use: [&#123; //使用的loader+ loader: 'url-loader', //这里用url-loader来处理图片 options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', + limit: 204800, // 当打包的图片文件小于204800Byte时, 将图片编译成base64的形式，进行打包。如果大于204800Byte时，则使用file-loader进行打包 &#125; &#125;, ] &#125;] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 现在我们看在使用url-loader打包的效果，我们用的图片是45830Byte。所以图片会被打包进bundle.js里，不会被单独的打包成一个文件。在页面上我们可以看到img的路径是一个base64的字符串： 图片打包常用的就file-loader 和 url-loader 了，更多的可以查文档:https://www.webpackjs.com/loaders/]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础配置-1]]></title>
    <url>%2F2019%2F05%2F30%2Fwebpack%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE-1%2F</url>
    <content type="text"><![CDATA[¶1.webpack配置 打开我们在上文中操作的文件夹， 12345678webpackdemo|- dist|- node-modules|- src|- index.html|- index.js|- package.json|- package-lock.json 为了后期文件便于管理，并且webpack的默认配置的打包入口文件就是src文件夹下的index.js文件。现在我们调整下文件结构。将index.js放在src目录下。 调整完成后应该是下面这样： 12345678webpackdemo|- dist|- node-modules|- src+ |- index.js|- index.html|- package.json|- package-lock.json 现在我们运行： 1npx webpack 这块webpack后面没有写入口文件，所以用的webpack默认的打包配置。 ¶2.现在我们手写下基础配置，在根目录下新建webpack.config.js配置文件,写入下面内容 webpack.config.js 1234567891011var path = require('path'); //引入node中的path模块module.exports = &#123; //将整个模块导出 entry: &#123; //入口文件 main: './src/index.js', &#125;, output: &#123; //打包输出路径 filename: 'bundle.js', //打包输出的文件名 path: path.resolve(__dirname, 'dist') //打包生成的文件夹，path必须是绝对路径, __dirname返回当前文件的绝对路径 &#125;&#125; 现在我们运行： 1npx webpack webpack.config.js Entrypoint main = bundle.js说明我们的配置生效了 ¶3.配置运行命令 npx webpack webpack.config.js 每次编译需要输入这么一长串。现在我们可以优化下命令 打开webpack.json，自定义不同mode下的打包命令，加上下面的两条命令，就ok了 1234567891011121314151617&#123; "name": "webpackdemo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123;+ "dev": "webpack --mode=development",+ "prod": "webpack --mode=production" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.32.2", "webpack-cli": "^3.3.2" &#125;&#125; 现在我们运行 1npm run dev 下面的界面说明我们打包成功了。同样也可以运行 npm run prod,打包生产环境的代码。(ps: dev环境下打包的代码不会被压缩。prod环境下打包的代码会被压缩) 以上我们就建好了基础配置，更多的配置可以查阅官方文档： webpack配置文档.]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2019%2F05%2F29%2Fwebpack%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[从这篇开始，会不定期更新webpack教程。希望能帮到在路上的小伙伴 webpack文档. 准备：1.安装node.js环境并配置好 ¶安装webpack tip: 安装之前一定要先安装node node官网. ¶1. 新建文件夹并进入 打开命令框工具，输入 1npm init 现在文件夹下会生成一个package.json文件，这个文件包含项目基本信息： 1234567891011121314151617181920// &lt;!-- package.json --&gt;&#123; "name": "webpackdemo", // 项目名称 "version": "1.0.0", // 项目版本 "description": "", // 描述 "main": "index.js", // 执行的入口文件 "scripts": &#123; // 配置项目命令 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], // 关键字 "author": "", // 作者(这里指开发者) "license": "ISC", // 标准(这个默认就ok) "dependencies": &#123; // 生产环境需要的依赖包 &#125;, "devDependencies": &#123; // 本地开发需要的依赖 "webpack": "^4.32.2", // 安装包 "webpack-cli": "^3.3.2" &#125;&#125; 接下来安装webpack,2种方法，一种是全局安装(通常我们不建议全局安装，因为每个项目需要的webpack版本可能会有不同，这里我们只说项目内安装)， 一种是项目内安装。 ¶项目内安装 npm install webpack webpack-cli --save-dev 等同于 npm install webpack webpack-cli -D 1npm install webpack webpack-cli --save-dev 安装完成后，输入 npx webpack -v 出现版本号说明安装成功 1npx webpack -v ¶现在新建文件，来体验下文件打包是什么样的 在文件夹的根目录下新建 index.html 文件，以及src文件夹。在src文件夹下面新建 index.js文件，并将下面相应的代码复制 ¶index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;欢迎来到蔓羊博客&lt;/div&gt; &lt;!-- 这里的dist 以及main.js 会在后面操作打包生成 --&gt; &lt;script src="./dist/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ¶index.js 1234567window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; root.appendChild(dom);&#125; 现在项目目录应该是这样： 1234567webpackdemo|- node-modules|- src|- index.html|- index.js|- package.json|- package-lock.json 建好了之后，打开git命令行工具，输入下面的命令。这个时候根目录下面会生成一个dist文件夹(ps:也就是通常所说的打包之后的文件)bi 这个时候可以在浏览器打开index.html,显示正常，说明打包成功 1npx webpack index.js npx：是webpack内置的打包命令。打包配置文件也是webpack默认的打包配置 以上就是webpack入门，想了解更多，请移步下篇文章 😄]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无插件上拉加载]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%97%A0%E6%8F%92%E4%BB%B6%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在写这篇文档之前，自己也写过移动端的上拉加载，不过一直以来都是用插件。 这次有时间吧原理好好梳理下； ¶原理： 浏览器内容高度(随内容多少变化)： document.documentelement.scrollHeight(ie的scrollHeight为document.body.scrollHeight) 滚动条的高度： dooument.documentelement.scrollTop(ie的scrollTop为document.body.scrollTop) 设备网页的可见高度(很多人说是设备的高度，自己斟酌)： widnow.screen.height 所以，当document.documentelement.scrollHeight = dooument.documentelement.scrollTop + widnow.screen.height时，就是滑到底部，需要请求下一页数据的时候 下面是核心代码： 12345678910111213141516171819window.onscroll = function(event)&#123; var screenHeight = window.screen.height; var scrollHeight = document.documentElement.scrollHeight; var scrollTop = document.documentElement.scrollTop; // 下面的10是在滑动在距离底部10px的时候,触发下一页数据请求.可自行调节 if(scrollHeight - (screenHeight + scrollTop) &lt; 10)&#123; //下面就是请求下一页数据的逻辑了，自行发挥 var htmlt = ''; for(var i = 0; i &lt; arr.length; i++)&#123; htmlt = htmlt + '&lt;p&gt;' + arr[i] + '&lt;/p&gt;'; &#125; var box = $('.box').html() $('.box').html(box + htmlt); &#125;&#125; 好用的话记得star呀~~😛 [上拉滚动 demo git地址]https://github.com/yagmdream/scroll]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客基础教程]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%85%A5%E9%97%A8%E7%BA%A7github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[¶准备：1.安装node.js环境并配置好 配置好之后，window + R 打开运行窗口，输入如下命令。出现版本号则说明安装成功 ¶2.github注册并新建一个仓库，仓库名必须和用户名相同，格式遵守：用户名.github.io 点击确定，仓库就建好了。 ¶3.在仓库上面最右边的菜单点击setting 然后向下拉到Github Pages,圈出的地方会有个网址（ps: 我这个是做了自定义域名），打开那个网址。你会发现项目在网络上可以打开了 ¶4.下来我们开始搭建安装Hexo 新建一个文件夹，进入文件夹，右键点击Git Bash Here打开命令行工具 输入命令, 开始全局安装hexo 1npm install hexo -g 安装完成之后输入 1hexo -v 出现下图，则安装成功 ¶5.输入hexo init进行项目初始化 出现下图 ，则说明项目初始化成功 ¶6.然后输入npm install安装所需的组件 1npm install ¶7.安装完成，就可以查看我们本地的博客了，输入： 1hexo s 打开圈出的地址：就能查看我们的博客雏形了😄 打开后正常应该是下面酱紫滴😝 ¶下来我们将博客放在我们github网址能访问的地方 ¶添加ssh(ps:这个是为了我们方便的将文章发布上去)，如果之前有添加过ssh，则略过 进入ssh文件夹1cs ~/.ssh ¶输入ls 查看是否有id_rsa，id_rsa.pub 这两个文件夹 1ls ¶如果没有，就输入下面的命令，然后回车。过程中会要求你输入github的账号和密码。 1ssh-keygen -t rsa -C &quot;你的github邮箱&quot; ¶输入完成之后。查看你的 C:\Users\hasee.ssh (ps:我的是这个) 大部分人应该是这个 C:\Users\window.ssh 文件件下面找到id_rsa.pub文件。 打开并复制里面的全部内容。然后登陆你的github,点击头像,选择settings ¶选择左侧边栏的SSH and GPG keys,点击New SSH keys ¶添加完成之后，输入下面的命令。看看是否添加成功 1ssh -T git@github.com ¶出现下面的提示，说明已经添加成功 ¶部署设置，在项目的根目录下找到_config.yml 文件，打开，拉到最下面，修改repository为你github博客的ssh 1234deploy: type: git repository: git@github.com:yagmdream/yagmdream.github.io.git branch: master ¶现在可以准备部署文章了，安装部署插件 1npm install hexo-deployer-git --save ¶安装完成之后，输入hexo d -g 生成及部署文章 1hexo d -g 现在可以线上访问： 用户名.github.io的地址 查看博客了😄]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mint-ui的cdn使用]]></title>
    <url>%2F2019%2F03%2F20%2Fmint-ui%E7%9A%84cdn%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[mint-ui平时使用多的经常是在类似 vue-cli 搭建好的框架中用import 引入，那如果我们cdn直接引入 script 。那里面的消息框该怎么用呢？ 12&lt;link rel="stylesheet" href="/Public/app_car_sales/css_v1_1/mint.ui.css"&gt;&lt;script src="/Public/app_car_sales/js_v1_1/mint.ui.js"&gt;&lt;/script&gt; toast、message调用看下面： 12345678//在 new Vue 对象的方法中直接调用就可以了this.$toast('这是一个提示窗');//message同理（全拼全部小写）this.$messagebox(&#123; title: '提示', message: '这是一个有确定按钮的弹窗', &#125;);]]></content>
      <tags>
        <tag>mint-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-super理解]]></title>
    <url>%2F2019%2F03%2F20%2Freact-super%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在看react的文档，发现react的逻辑都是以component为基础的。 比如： 123456class Clock extends React.Component &#123; constructor(props)&#123; super(props); console.log(this); &#125; &#125; 在es6中class的继承是通过extends关键字实现的。constructor 是类默认的构造方法。那么super是做什么用的？ ¶1.有super() or 无super() 我们现在注释掉super(props) 123456class Clock extends React.Component &#123; constructor(props)&#123; //super(props); console.log(this); &#125; &#125; 提示this不存在，就是说super是子类为了继承父类的this。 子类是没有自己的this的，它只能继承父类的this对象，然后对其操作。而super就是将父类的this继承给子类的。没有super，子类是无法拿到this对象的。 所以我们这样写 super() 123456class Clock extends React.Component &#123; constructor(props)&#123; super(); console.log(this); &#125; &#125; 打印出this为： ¶2.super(props) or super() 现在我们打印下 this.props 123456class Clock extends React.Component &#123; constructor(props)&#123; super(props); console.log(this.props); &#125; &#125; 现在是可以正常打印出结果的，现在将super中的props删掉 123456class Clock extends React.Component &#123; constructor(props)&#123; super(); console.log(this.props); &#125; &#125; 也就是说，如果我们想在constructor中使用props，super中就必须要带参数。否则是无法拿到值的。 所以还是建议，不论constructor中是否用到props ， 都这样写super(props); 这样不论什么情况都不会有拿不到值或者报错的情况 先写到这吧，要是有别的认知再来补充😝😝~~~]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react初识]]></title>
    <url>%2F2019%2F02%2F20%2Freact%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[新年伊始，领导说后面相面考虑用react开发，最近看了react的文档。真心话，觉得好复杂。个人想法ps: 也可能是因为之前用的vue，一时半会转不过来的原因 。希望不会有人打我😂 ¶话不多说 我们先来感受下 注意：react对node版本有要求: 1Node &gt;= 6 and npm &gt;= 5.2 首先先全局安装create-react-app这个脚手架， 为了后续执行命令用： 1npm install -g create-react-app 然后开始创建我们的第一个react项目 1create-react-app myapp //myapp是项目名 创建完成之后： 12cd myapp //进入项目yarn start //运行 用npm start 也可以，个人习惯 如果出现下面这个提示，说明3000端口被占用，找到这个运行的程序关掉就ok 然后重新运行 1yarn start 出现这个，我们的项目就顺利建成了 🙈🙈🙈~~]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdowm表情包]]></title>
    <url>%2F2019%2F02%2F20%2Fmarkdowm%E8%A1%A8%E6%83%85%E5%8C%85%2F</url>
    <content type="text"><![CDATA[markdown可以添加表情了😂 更多表情戳这里：https://www.webpagefx.com/tools/emoji-cheat-sheet/]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node创建一个服务]]></title>
    <url>%2F2019%2F02%2F11%2Fnode%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[¶node创建一个服务 在创建服务之前，要先安装node以及npm包管理（现在的node都带有默认的npm包管理） 通过这个demo演示创建服务的过程 12345678910111213141516171819202122232425262728//http.js//引入http模块var http = require('http');//创建一个服务http.createServer(function(request, response)&#123; //request 请求体 //response 响应体 //writeHead 设置请求头 response.writeHead(200, &#123;'Content-Type': 'text/html; charset = utf-8'&#125;) //默认一般会有2次访问。即页面选项卡前的图标，一般建议过滤掉 if(request.url !== '/favicon.ico')&#123; //在控制台打印 console.log('hello'); //网页打印 response.write('hello world'); //控制台打印出请求体 console.log(request); //请求完成之后，要结束响应 response.end('你好，世界'); &#125;&#125;).listen(8000); //listen 监听本地8000端口//提示监听的端口号console.log('Server runningat http://127.0.0.1:8000');]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加入购物车动画-基于fly.js插件]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%A8%E7%94%BB-%E5%9F%BA%E4%BA%8Efly-js%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[购物车飞入动画基于jquery的 fly.js插件,只需设置起点和终点的坐标即可，抛物线由fly.js来完成 资源下载地址：[https://github.com/amibug/fly]https://github.com/amibug/fly 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;飞入动画&lt;/title&gt; &lt;style&gt; .test&#123;background: red;width: 50px;height:50px;&#125; .box &#123; width: 100%; height: 1000px; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;飞入插件&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="fly.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 飞到的终点的坐标 var globalLeft = $('.box').offset().left; var globalTop = $('.box').offset().top - $(document).scrollTop() + 1000; //绑定点击事件 $('.box').on('click', fly); &lt;!-- 飞入执行 --&gt; function fly(event)&#123; console.log(10); var flyer = $('&lt;div class="test"&gt;&lt;/div&gt;'); flyer.fly(&#123; start: &#123; left: event.pageX, top: event.pageY-$(document).scrollTop() &#125;, end: &#123; top: globalTop, left: globalLeft, width: 0, height: 0, &#125;, onEnd: function()&#123; this.destroy(); &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery.range双滑块范围选择]]></title>
    <url>%2F2019%2F01%2F14%2FjQuery-range%E5%8F%8C%E6%BB%91%E5%9D%97%E8%8C%83%E5%9B%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[基于jquery的双滑块范围选择插件jquery.range.js 效果（颜色默认为绿色，这里我改了本地的css文件）： 1.首先载入jquery以及range插件相关文件： 123&lt;link rel="stylesheet" href="range.css"&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="range.min.js"&gt;&lt;/script&gt; 2.然后在需要展示滑块的地方放入下面代码（这里设置默认范围值为 0,80 ）： 1&lt;input type="hidden" value="0, 80" id="range" class="slider-input"/&gt; 3.在js中写入下面部分： 12345678910111213141516 $('.slider-input').jRange(&#123; from: 0, //滑块范围的初始值 to: 80, //滑块范围的终止值 step: 1, //设置步长 scale: [0,20,40,60,80], //滑动条下方的尺度变标签 format: '%s', //数值格式 width: 300, //进度条的宽度 showLabels: true, //是否显示滑动条下方的尺寸标签 showScale: false, //是否显示滑块上方的数值标签 isRange: true, //是否为选取范围 onstatechange: function(e)&#123; //滑块范围改变时触发的方法 console.log(e); &#125; &#125;); $('.slider-input').jRange('setValue', '25, 50'); //滑块赋值 上面的设置在文档中也有详细的描述，基本都可以满足我们的需求 jquery.range文档参考：https://github.com/nitinhayaran/jRange.]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
