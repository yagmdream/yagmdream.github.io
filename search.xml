<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack处理ES6语法-7]]></title>
    <url>%2F2019%2F07%2F03%2Fwebpack%E5%A4%84%E7%90%86ES6%E8%AF%AD%E6%B3%95-7%2F</url>
    <content type="text"><![CDATA[我们知道，ES6语法目前是不能被大部分主流浏览器所识别的。我们项目中所用的框架都是帮我们做好了ES6转ES5。所以我们可以直接使用ES6。 那么我们自己去配置项目的时候语法怎么处理呢。下面我们就来看下语法转换。 babel官网 ¶1.安装babel 1npm install --save-dev babel-loader @babel/core webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const webpack = require('webpack');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', entry: &#123; main: './src/index.js', &#125;, devServer: &#123; contentBase: path.join(__dirname, 'dist'), clientLogLevel: 'info', open: true, host: 'localhost', port: '9090', inline: true, proxy: &#123; '/': &#123; target: 'http://yagmblog.com/', &#125;, '/upload': &#123; target: 'http://yagmblog.com' &#125; &#125;, hot: true, hotOnly: true, &#125;, module: &#123; rules: [&#123;+ test: /\.js$/, + exclude: /(node_modules|bower_components|lib)/,+ loader: 'babel-loader' &#125;,&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), new webpack.HotModuleReplacementPlugin() ], output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 文件结构 123456789101112131415161718192021222324252627|- dist|- node-modules|- src |- assets |- images | |- 1.jpg |- css | |- index.css |- scss | |- index.scss |- iconfont |- demo_index.html |- demo.css |- iconfont.css |- iconfont.eot |- iconfont.svg |- iconfont.js |- iconfont.ttf |- iconfont.woff |- iconfont.woff2 |- index.js|- index.html|- package.json|- package-lock.json|- webpack.config.js+ |- .babelrc 安装@babel/preset-env 1npm install @babel/preset-env --save-dev .babelrc 123+&#123;+ "presets": ["@babel/preset-env"]+&#125; index.js 12345678const arr = [ new Promise(() =&gt; &#123;&#125;), new Promise(() =&gt; &#123;&#125;)]arr.map(val =&gt; &#123; console.log(val);&#125;) package.json 12345"scripts": &#123;+ "dev": "webpack --mode development --env development --colors", "prod": "webpack --mode production --env production --colors", "start": "webpack-dev-server --colors" &#125;, 执行我们开发环境的打包 1npm run dev 打包完成后我们能看到dist目录下面的main.js, 最下面我们可以找到下面的这段代码(也可以直接搜索index.js)。 const被编译成var，箭头语法也被编译成function。已经实现了ES6到ES5的转换。但这只转换了一部分。在一些低版本浏览器中promise和map依然识别不了。 123456789101112/***/ "./src/index.js":/*!**********************!*\ !*** ./src/index.js ***! \**********************//*! no static exports found *//***/ (function(module, exports) &#123;eval("// import \"./assets/css/index.css\"\nvar arr = [new Promise(function () &#123;&#125;), new Promise(function () &#123;&#125;)];\narr.map(function (val) &#123;\n console.log(val);\n&#125;);\n\n//# sourceURL=webpack:///./src/index.js?");/***/ &#125;)/******/ &#125;); ¶2.兼容低版本浏览器 安装@babel/polyfill 1npm install --save @babel/polyfill index.js 12345678910+import "@babel/polyfill"const arr = [ new Promise(() =&gt; &#123;&#125;), new Promise(() =&gt; &#123;&#125;)]arr.map(val =&gt; &#123; console.log(val);&#125;) 执行我们开发环境的打包 1npm run dev 1234567891011/***/ "./node_modules/@babel/polyfill/lib/index.js":/*!***************************************************!*\ !*** ./node_modules/@babel/polyfill/lib/index.js ***! \***************************************************//*! no static exports found *//***/ (function(module, exports, __webpack_require__) &#123;"use strict";eval("\n\n__webpack_require__(/*! ./noConflict */ \"./node_modules/@babel/polyfill/lib/noConflict.js\");\n\nvar _global = _interopRequireDefault(__webpack_require__(/*! core-js/library/fn/global */ \"./node_modules/core-js/library/fn/global.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;\n\nif (_global.default._babelPolyfill &amp;&amp; typeof console !== \"undefined\" &amp;&amp; console.warn) &#123;\n console.warn(\"@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended \" + \"and may have consequences if different versions of the polyfills are applied sequentially. \" + \"If you do need to load the polyfill more than once, use @babel/polyfill/noConflict \" + \"instead to bypass the warning.\");\n&#125;\n\n_global.default._babelPolyfill = true;\n\n//# sourceURL=webpack:///./node_modules/@babel/polyfill/lib/index.js?");/***/ &#125;), 从打包的main.js中可以看到，Promise和map方法 @babel/polyfill 已经帮我们做了实现，但是打包文件突然增大到400多kb。是因为main.js文件将整个 polyfill都打包进来。但是我们想要的是我们在index.js文件用到的方法帮我们做打包处理，没用到的方法就不需要打包进main.js ¶3.现在我们配置让它只打包我们用到的方法 .babelrc 1234567891011&#123; "presets": [ [ "@babel/preset-env",+ &#123;+ "useBuiltIns": "usage",+ &#125; ] ] &#125; 执行我们开发环境的打包 1npm run dev 当我们配置了.babelrc的 “useBuiltIns”: “usage” 再次打包,发现我们的打包文件已经到90多kb了。“useBuiltIns”: &quot;usage&quot;的特性就是当polyfill低版本的浏览器添加一些特性的时候，不是把所有的特性都加进去。而是我们用到什么才去添加什么。 ¶4.设置浏览器版本 .babelrc 12345678910111213141516&#123; "presets": [ [ "@babel/preset-env", &#123;+ "targets": &#123;+ "edge": "17",+ "firefox": "60",+ "safari": "11.1",+ "chrome": "67"+ &#125;, "useBuiltIns": "usage", &#125; ] ]&#125; “chrome”: “67” 指编译的代码要运行在67版本的chrome浏览器上， 如果chrome67版本的chrome支持promise语法，则不转换，否则就转换。 执行我们开发环境的打包 1npm run dev ¶5.插件开发 平时开发直接引入就可以用了。但如果是开发插件，上面那种promise 全局引入会污染全局环境。下面用插件安装的方式来引入 安装pluginTransformRuntime 123npm install --save-dev @babel/plugin-transform-runtimenpm install --save-dev @babel/runtimenpm install --save-dev @babel/runtime-corejs2 babelrc 12345678910111213141516171819202122232425262728&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": &#123; "edge": "17", "firefox": "60", "safari": "11.1", "chrome": "67" &#125;, "useBuiltIns": "usage", &#125; ] ],+ "plugins": [+ [+ "@babel/plugin-transform-runtime",+ &#123;+ "absoluteRuntime": false,+ "corejs": 2,+ "helpers": true,+ "regenerator": true,+ "useESModules": false+ &#125;+ ]+ ]&#125; 执行我们开发环境的打包 1npm run dev 打包完成之后，可以看到 promise和map依然会帮我们进行处理。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-devServer开发配置-6]]></title>
    <url>%2F2019%2F06%2F28%2Fwebpack-devServer%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE-6%2F</url>
    <content type="text"><![CDATA[webpack-dev-server是一个快速搭建本地运行环境的工具，实际开发中我们需要请求接口调用数据。在我们以前的打包文件中，直接在浏览器打开是file协议，而file是无法调取接口的，webpack-dev-server可以帮我们将file协议改成http协议。 webpack-dev-server 实现以下功能： 自动打开浏览器 调试接口 实时刷新 热更新 使用代理 ¶1.安装 webpack-dev-server 插件 (自动打开浏览器 | 调试接口 | 实时刷新 | 使用代理) 1npm install webpack-dev-server -D webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', entry: &#123; main: './src/index.js', &#125;,+ devServer: &#123; //添加devServer配置+ contentBase: path.join(__dirname, 'dist'), // 设置文件的根目录+ clientLogLevel: 'info', // 在开发工具(DevTools)的控制台(console)将显示消息，如：在重新加载之前，在一个错误之前，或者模块热替换(Hot Module Replacement)启用+ open: true, // 编译完成后自动帮我们打开默认浏览器+ host: 'localhost', // 默认为localhost, 如果在局域网内想让别人也可以访问，可以设置成你的本机地址，比如：192.168.0.120+ port: '9090', // 页面访问的端口+ inline: true, // 实时更新+ proxy: &#123; //设置代理+ '/api': &#123; // 如果请求到 /api/users , 现在会被代理到请求 http://yagmblog.com/api/users , /api会被target替换。如果不想始终传递 /api, 则需要重写路径。 + target: 'http://yagmblog.com/',+ pathRewrite: &#123; //重写路径+ '/api': ''+ &#125;+ &#125;,+ '/upload': &#123; //配置图片上传代理+ target: 'http://yagmblog.com'+ &#125;+ &#125;,+ &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(), ], output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; package.json 12345678910111213141516171819202122232425262728293031323334&#123; "name": "webpackdemo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "dev": "webpack --mode development --env development --watch --colors --progress", "prod": "webpack --mode production --env production --colors --progress",+ "start": "webpack-dev-server --colors --progress", //配置本地开发运行命令 --colors 对编译提示信息添加颜色，--progress显示编译进度 "server": "node server.js " &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "autoprefixer": "^9.5.1", "clean-webpack-plugin": "^3.0.0", "css-loader": "^2.1.1", "express": "^4.17.1", "extract-text-webpack-plugin": "^4.0.0-beta.0", "file-loader": "^3.0.1", "html-webpack-plugin": "^3.2.0", "node-sass": "^4.12.0", "postcss-loader": "^3.0.0", "sass-loader": "^7.1.0", "style-loader": "^0.23.1", "url-loader": "^1.1.2", "webpack": "^4.32.2", "webpack-cli": "^3.3.2", "webpack-dev-middleware": "^3.7.0", "webpack-dev-server": "^3.7.2" &#125;&#125; ¶2.模块热替换 HMR( HotModuleReplacementPlugin ) 现在我们将webpack.config.js进行修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');+ const webpack = require('webpack'); module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-souce-map', entry: &#123; main: './src/index.js', &#125;, devServer: &#123; contentBase: path.join(__dirname, 'dist'), clientLogLevel: 'info', open: true, host: '192.168.0.129', port: '9090', inline: true, proxy: &#123; '/': &#123; target: 'http://yagmblog.com/', &#125;, '/upload': &#123; target: 'http://yagmblog.com' &#125; &#125;,+ hot: true, // 配置devServe的热更新+ hotOnly: true, // 如果更新失败，不做任何操作： 默认刷新 &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ "style-loader", "css-loader", 'postcss-loader', ], &#125;,&#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2, &#125; &#125;, 'sass-loader', 'postcss-loader', ] &#125;,&#123; test: /\.(eot|ttf|svg|woff|woff2)$/, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', publicPath: './iconfont', outputPath: 'iconfont', &#125; &#125; ], &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpack', // filename: 'bundle.html', template: './index.html', &#125;), new CleanWebpackPlugin(),+ new webpack.HotModuleReplacementPlugin() // 热更新插件 ], output: &#123; // publicPath: '/', filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;!-- 设置文档标题 --&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;+ &lt;div id="root"&gt;蔓羊博客&lt;/div&gt; &lt;span class="iconfont icon-changjingguanli"&gt;&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; index.js 1+ import "./assets/css/index.css" index.css 123+ div &#123;+ color: pink;+ &#125; 写好后，运行 1npm run start 现在浏览器页面上显示粉色的 蔓羊博客。现在打开index.css文件，将样式改成绿色,保存。： 123div &#123;+ color: green;&#125; 返回浏览器页面, 现在可以看到控制台doc里面没有请求，也就是没有刷新，但是字体已经变成绿色了.这就是 HotModuleReplacementPlugin 的作用。 在不刷新浏览器的情况下可以即时的更改css样式。对于前端写经常写样式的小伙伴来说。真的是非常方便了。但是对js文件就不起作用了。 ¶2.1 js模块热替换 现在我们在src下面和index.js目录同级新建一个test.js 文件 test.js 12345678+function add()&#123;+ var div = document.createElement('div');+ div.innerHTML = 'hello';+ div.setAttribute('id', 'add')+ document.body.appendChild(div);+&#125;+ export default add index.js 123456 import "./assets/css/index.css"+ import add from "./test.js";+ window.onload = function()&#123;+ add();+ &#125; 上面的代码想实现的是， 创建一个div并设置内容为hello, 然后挂载到body上 现在重新运行： 1npm run start 可以看到hello 已经显示在页面上了。 现在我们将test.js文件内容 hello 999修改为 hello world,保存文件。返回查看浏览器，这里注意，不要刷新浏览器。会发现我们页面上的hello并没有变 12345678function add()&#123; var div = document.createElement('div');+ div.innerHTML = 'hello world'; div.setAttribute('id', 'add') document.body.appendChild(div);&#125;export default add 修改index.js 123456789101112131415import "./assets/css/index.css"import add from "./test.js";window.onload = function()&#123; add();&#125;+if(module.hot)&#123; // 相当于监听+ module.hot.accept('./test.js', (() =&gt; &#123; // 当test.js文件有变动时，先移除原来的dom，在添加新的dom+ document.body.removeChild(document.getElementById('add'));+ add();++ &#125;))+&#125; 保存后刷新浏览器，我们看到现在页面上显示的是刚才修改过的hello world。现在我们修改test.js文件。将hello world修改成world。保存。返回查看浏览器不要刷新，这个时候页面上的内容已经变成world 。 12345678function add()&#123; var div = document.createElement('div');+ div.innerHTML = 'world'; div.setAttribute('id', 'add') document.body.appendChild(div);&#125;export default add 从上面可以知道。当我们使用热更新时，只有样式会被更新。js文件并不会更新。需要js更新，就需要手动编写module.hot。先进行dom移除再添加。但是我们在写项目的时候一般也不会写 module.hot。项目依然可以更新是为什么呢？ 这是由于我们写的项目所用的框架里面已经集成了热更新，比如：vue-loader, react-hot-loader 。所以一般不需要我们自己去写。但是原理我们要明白。其实css文件也不会更新。只不过css-loader里面帮我们集成了更新的功能。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包iconfont-5]]></title>
    <url>%2F2019%2F06%2F27%2Fwebpack%E6%89%93%E5%8C%85iconfont-5%2F</url>
    <content type="text"><![CDATA[在项目中，避免不了要使用字体图标文件。这里我们看下iconfont打包配置 阿里巴巴矢量图标 将下载的iconfont文件放入src/assets/下面的iconfont文件夹下 开始之前，为了文件结构清晰，我们将js, css, scss, iconfont文件统一放入assets文件夹，目录如下： 1234567891011121314151617181920212223242526|- dist|- node-modules|- src+ |- assets+ |- images+ | |- 1.jpg+ |- css + | |- index.css + |- scss + | |- index.scss + |- iconfont+ |- demo_index.html+ |- demo.css+ |- iconfont.css+ |- iconfont.eot+ |- iconfont.svg+ |- iconfont.js+ |- iconfont.ttf+ |- iconfont.woff+ |- iconfont.woff2+ |- index.js|- index.html|- package.json|- package-lock.json|- webpack.config.js index.js 做以下改动 123456789101112131415161718192021+import yimg from "./assets/images/1.jpg" //更改引入目录+import test from "./assets/css/index.css" //更改引入目录+import avatar from "./assets/sass/index.scss" //更改引入目录+import "./assets/iconfont/iconfont.css" //引入iconfont.css文件window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; //var image = new Image(); //image.src = yimg; //image.classList.add('test'); //image.classList.add('img'); root.appendChild(dom); root.append(image);&#125; index.html 文件使用字体文件 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;!-- 设置文档标题 --&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt;+ &lt;span class="iconfont icon-changjingguanli"&gt;&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js中加入打包处理方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657module.exports = &#123; module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ 'style-loader', 'css-loader', 'postcss-loader', ] &#125;,&#123; test: /\.scss/, use: [ 'style-loader', 'css-loader', 'postcss-loader', &#125;,&#123; test: /\.scss/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoader: 2 &#125; &#125; 'scss-loader', 'postcss-loader', ]+ &#125;,&#123;+ test: /\.(eot|ttf|svg|woff|woff2)$/, //匹配iconfont文件+ use: [+ &#123;+ loader: 'file-loader', //使用file-loader处理+ options: &#123; //配置项+ name: '[name].[ext]', // 打包生成的文件名字+ publicPath: './iconfont', //打包完成后index.html引入的iconfont的路径+ outputPath: 'iconfont', // 打包完成后dist下面放iconfont文件的文件夹+ &#125;+ &#125;+ ],+ &#125;] &#125;, plugins: [], &#125; 运行打包命令 npm run dev , 可以看到iconfont被成功引入到页面中：]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack便捷打包配置-4]]></title>
    <url>%2F2019%2F06%2F27%2Fwebpack%E4%BE%BF%E6%8D%B7%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE-4%2F</url>
    <content type="text"><![CDATA[html-webpack-plugin clean-webpack-plugin 前面我们打开文件一直用的自己写的入口文件 index.html 。在实际的开发生产过程中。需要把入口文件以及打包后的文件上传到服务器。这样我们每次都要把index.html文件放在打包文件夹里面，并且一个个去引入生成的js及css文件(ps:生成的文件名一般都带有hash值，来保证页面上引入的文件是最新的打包文件)这样会很麻烦。其实是有插件来帮我们做这些事情的。 html-webpack-plugin 为打包的文件生成一个入口的html文件。默认index.html ¶1. html-webpack-plugin 插件 1+ npm install --save-dev html-webpack-plugin webpack.config.js文件 123456789101112+ const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; module: &#123;&#125;,+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: 'mywebpackdemo', //设置文档标题+ filename: 'index.html', //设置生成html文件的名字+ template: './index.html' // 如果想要生成的文件是你自己写的，就把你写的文件路径写在这，作为模板。这里我将根目录下的index.html作为模板+ &#125;)+ ], &#125; index.html文件 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;!-- 设置文档标题 --&gt;+ &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; - &lt;script src="./dist/main.js"&gt;&lt;/script&gt; //去掉前面手动引入的文件&lt;/body&gt;&lt;/html&gt; 现在打开命令行终端, 输入 打包命令： npm run dev 1npm run dev 打包完成后，在浏览器打开dist下面的index.html文件，可以看到生成的index.html已经自动为我们引入了main.js文件 ¶1. clean-webpack-plugin 插件 clean-webpack-plugin 一个清除文件的插件。 可以帮我们每次打包时，自动帮我们清除dist目录下面的原来的打包文件。 安装 1npm install --save-dev clean-webpack-plugin webpack.config.js文件 12345678910111213141516 const HtmlWebpackPlugin = require('html-webpack-plugin');+ const &#123; CleanWabpckPlugin &#125; = require('clean-webpack-plugin'); //这里要注意下，这是webpack v4.32.1版本以上(包括v4.32.1) , CleanWabpckPlugin的引入方式。如引入错误，会提示 CleanWebpackPlugin is not a constructor+ const CleanWebpackPlugin = require('clean-webpack-plugin'); // 这是webpack v4.32.1版本以下的 引入方式。 module.exports = &#123; module: &#123;&#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'mywebpackdemo', //设置文档标题 filename: 'index.html', //设置生成html文件的名字 template: './index.html' // 如果想要生成的文件是你自己写的，就把你写的文件路径写在这，作为模板。这里我将根目录下的index.html作为模板 &#125;),+ new CleanWebpackPlugin(), ], &#125; 为了说明CleanWebpackPlugin 的作用，可以在dist里面多建几个文件 然后打开命令行终端, 输入 打包命令： npm run dev 1npm run dev 打包完成后，可以看看刚才新建的文件是否都被删除了。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack样式打包-3]]></title>
    <url>%2F2019%2F06%2F04%2Fwebpack%E6%A0%B7%E5%BC%8F%E6%89%93%E5%8C%85-3%2F</url>
    <content type="text"><![CDATA[这篇的重点： style-loader css-loader sass-loader postcss-loader 添加厂商前缀 写前端项目时，少不了写样式。这篇就看看css打包是如何配置的 ¶1.loader的执行顺序：从下到上，从右到左 12345678910&#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader',+ 'sass-loader',+ 'less-loader',+ 'postcss-loader',+ ]+ &#125; ¶2.css打包 先来看下项目结构, 新建css文件以及index.css文件。我们需要的效果是将图片变小，并且偏移： 123456789101112webpackdemo|- dist|- node-modules|- src |- images | |- 1.jpg+ |- css + | |- index.css //添加的样式文件|- index.html|- index.js|- package.json|- package-lock.json index.css 12345+.test &#123;+ width: 200px;+ height: 200px;+ transform: translate(100px, 100px);+&#125; index.js 12345678910111213141516import yimg from "./images/1.jpg"+import index from "./css/index.css" // index.js引入样式文件window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; var image = new Image(); image.src = yimg;+ image.classList.add('test'); // 这里的test是index.css里面的类名 root.appendChild(dom); root.append(image);&#125; 修改webpack配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ],+ &#125;,&#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader',+ ]+ &#125;] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 安装style-loader css-loader css-loader可以识别并打包css文件。style-loader 是将处理的样式挂载到页面上 文档移步这里： style-loader css-loader。 1npm install style-loader css-loader --save-dev 安装完成后，执行： 1npm run dev 浏览器打开index.html就可以看到css已经有效果了 ¶3.scss打包 效果是将scss文件进行编译打包，是图片顺时针转70度，修改文件目录结构，添加sass文件夹以及index.scss文件 1234567891011121314webpackdemo|- dist|- node-modules|- src |- images | |- 1.jpg |- css | |- index.css + |- scss + | |- index.scss //添加的scss文件|- index.html|- index.js|- package.json|- package-lock.json index.scss 12345678+body &#123;+ .img &#123;+ margin-top: 300px;+ width: 200px;+ height: 200px;+ transform: rotate(70deg);+ &#125;+&#125; index.js 123456789101112131415161718import yimg from "./images/1.jpg"import index from "./css/index.css" +import avatar from "./sass/index.scss" //引入index.scss文件window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; var image = new Image(); image.src = yimg;+ //image.classList.add('test'); + image.classList.add('img'); //将img类赋值到src上面 root.appendChild(dom); root.append(image);&#125; 修改webpack配置 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ 'style-loader', 'css-loader', ]+ &#125;,&#123;+ test: /\.scss/,+ use: [+ 'style-loader',+ &#123;+ loader: 'css-loader', //css-loader+ options: &#123; + importLoader: 2 //当index.scss文件中有导入 @import b.scss 文件时，需要重新加载css-loader的前面的loader插件+ &#125;+ &#125;+ 'scss-loader' //将scss语法编译成css语法+ ]+ &#125; ] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 安装sass-loader sass-loader将scss文件转译成css文件以让浏览器识别。 文档移步这里： sass-loader 1npm install sass-loader node-sass --save-dev 安装完成后，执行： 1npm run dev 浏览器打开index.html就可以看到scss已经被成功的编译打包成css语法了 ¶4.postcss-loader 添加厂商前缀 一般写样式的时候，我们为了兼容主流浏览器，都会在css3的新属性前加上厂商前缀。当项目变的很大的时候，手动去写就变的非常麻烦了。那么postcss-loader就是帮助我们加自动的添加前缀的。 新建postcss.config.js 12345+module.exports = &#123;+ plugins: [+ require('autoprefixer')+ ]+ &#125; 修改webpack配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; rules: [&#123; test: /\.jpg$/, use: [&#123; loader: 'url-loader', options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', limit: 204800, &#125; &#125; ], &#125;,&#123; test: /\.css$/, use: [ 'style-loader', 'css-loader',+ 'postcss-loader', ] &#125;,&#123; test: /\.scss/, use: [ 'style-loader', 'css-loader',+ 'postcss-loader', &#125;,&#123; test: /\.scss/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoader: 2 &#125; &#125; 'scss-loader',+ 'postcss-loader', ] &#125; ] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 安装postcss-loader postcss-loader自动添加厂商前缀。 文档移步这里： postcss-loader 1npm i -D postcss-loader 安装 autoprefixer 插件 1npm install autoprefixer --save-dev 安装完成后，执行： 1npm run dev 浏览器打开index.html就可以看到transform前面已经自动加上了-webkit-]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack图片打包-2]]></title>
    <url>%2F2019%2F06%2F03%2Fwebpack%E5%9B%BE%E7%89%87%E6%89%93%E5%8C%85-2%2F</url>
    <content type="text"><![CDATA[webpack只认识js文件和JSON文件，所以打包的时候默认是会对这两种类型的文件进行打包。但实际的项目中，除了js和JSON，还有css， img等文件。 这些文件就需要依赖loader来进行编译然后才能被浏览器识别并渲染出来。loader就是文件打包的一种解决方案。 下面我们要认识的是： 图片打包 css打包 先来说图片打包，现在看下目录结构，新建images文件夹，随便下载一张图片放进去： 12345678910webpackdemo|- dist|- node-modules|- src+ |- images+ |- 1.jpg|- index.html|- index.js|- package.json|- package-lock.json 在index.js文件中添加如下内容，目的是将图片引入进来 index.js 12345678910111213+import yimg from "./images/1.jpg" //先将js引入进来window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; + var image = new Image(); //创建img标签+ image.src = yimg; // 将img的src属性设置成我们引入的图片 root.appendChild(dom);+ root.append(image);&#125; 由于webpack默认不认识以jpg/png 这些后缀名结尾的文件，所以要在webpack.config.js中配置loader。修改webpack.config.js文件， 这里处理图片文件用file-loader。 webpack.config.js 1234567891011121314151617181920212223242526var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;,+ module: &#123; //是配置我们的模块规则+ rules: [&#123; //rules里面可以配置各种文件处理的规则+ test: /\.jpg|png|jpeg|gif$/, //匹配以jpg|png|jpeg|gif结尾的文件+ use: [&#123; //使用的loader+ loader: 'file-loader', //这里用file-loader来处理图片+ options: &#123; //options里面可以配置详细的处理信息+ name: '[name].[ext]?[hash]', // 打包文件名+ publicPath: './dist/img', // 打包的公共路径(ps:默认是在output.path下面)+ outputPath: 'img', // 打包的文件放在img文件夹内。比如默认打包出来是在 dist/1.img。设置outpurpath就是dist/img/1.jpg+ &#125;+ &#125;,+ ]+ &#125;]+ &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; file-loader配置完成后，我们需要安装file-loader, npm install file-loader --save-dev 或者 npm install file-loader -D 都可以： 1npm install file-loader --save-dev 安装完成之后，就可以在命令行输入我们之前配置好的命令： 1npm run dev 这是打包完成目录及效果, 这个时候img被单独打包成一个文件： file-loader 打包的图片会被直接img引用，页面渲染的时候会发送请求。如果图片很小。页面中又有很多的时候时候，是很浪费下载通道的。 这个时候我们可以用url-loader。 url-loader: url-loader 功能类似于 file-loader，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。 现在我们改下配置： webpack.config.js 123456789101112131415161718192021222324252627var path = require('path');module.exports = &#123; mode: "development", entry: &#123; main: './src/index.js', &#125;, module: &#123; //是配置我们的模块规则 rules: [&#123; //rules里面可以配置各种文件处理的规则 test: /\.jpg|png|jpeg|gif$/, //匹配以jpg|png|jpeg|gif结尾的文件 use: [&#123; //使用的loader+ loader: 'url-loader', //这里用url-loader来处理图片 options: &#123; name: '[name].[ext]?[hash]', publicPath: './dist/img', outputPath: 'img', + limit: 204800, // 当打包的图片文件小于204800Byte时, 将图片编译成base64的形式，进行打包。如果大于204800Byte时，则使用file-loader进行打包 &#125; &#125;, ] &#125;] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 现在我们看在使用url-loader打包的效果，我们用的图片是45830Byte。所以图片会被打包进bundle.js里，不会被单独的打包成一个文件。在页面上我们可以看到img的路径是一个base64的字符串： 图片打包常用的就file-loader 和 url-loader 了，更多的可以查文档:https://www.webpackjs.com/loaders/]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础配置-1]]></title>
    <url>%2F2019%2F05%2F30%2Fwebpack%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE-1%2F</url>
    <content type="text"><![CDATA[¶1.webpack配置 打开我们在上文中操作的文件夹， 12345678webpackdemo|- dist|- node-modules|- src|- index.html|- index.js|- package.json|- package-lock.json 为了后期文件便于管理，并且webpack的默认配置的打包入口文件就是src文件夹下的index.js文件。现在我们调整下文件结构。将index.js放在src目录下。 调整完成后应该是下面这样： 12345678webpackdemo|- dist|- node-modules|- src+ |- index.js|- index.html|- package.json|- package-lock.json 现在我们运行： 1npx webpack 这块webpack后面没有写入口文件，所以用的webpack默认的打包配置。 ¶2.现在我们手写下基础配置，在根目录下新建webpack.config.js配置文件,写入下面内容 webpack.config.js 1234567891011var path = require('path'); //引入node中的path模块module.exports = &#123; //将整个模块导出 entry: &#123; //入口文件 main: './src/index.js', &#125;, output: &#123; //打包输出路径 filename: 'bundle.js', //打包输出的文件名 path: path.resolve(__dirname, 'dist') //打包生成的文件夹，path必须是绝对路径, __dirname返回当前文件的绝对路径 &#125;&#125; 现在我们运行： 1npx webpack webpack.config.js Entrypoint main = bundle.js说明我们的配置生效了 ¶3.配置运行命令 npx webpack webpack.config.js 每次编译需要输入这么一长串。现在我们可以优化下命令 打开webpack.json，自定义不同mode下的打包命令，加上下面的两条命令，就ok了 1234567891011121314151617&#123; "name": "webpackdemo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123;+ "dev": "webpack --mode=development",+ "prod": "webpack --mode=production" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.32.2", "webpack-cli": "^3.3.2" &#125;&#125; 现在我们运行 1npm run dev 下面的界面说明我们打包成功了。同样也可以运行 npm run prod,打包生产环境的代码。(ps: dev环境下打包的代码不会被压缩。prod环境下打包的代码会被压缩) 以上我们就建好了基础配置，更多的配置可以查阅官方文档： webpack配置文档.]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2019%2F05%2F29%2Fwebpack%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[从这篇开始，会不定期更新webpack教程。希望能帮到在路上的小伙伴 webpack文档. 准备：1.安装node.js环境并配置好 ¶安装webpack tip: 安装之前一定要先安装node node官网. ¶1. 新建文件夹并进入 打开命令框工具，输入 1npm init 现在文件夹下会生成一个package.json文件，这个文件包含项目基本信息： 1234567891011121314151617181920// &lt;!-- package.json --&gt;&#123; "name": "webpackdemo", // 项目名称 "version": "1.0.0", // 项目版本 "description": "", // 描述 "main": "index.js", // 执行的入口文件 "scripts": &#123; // 配置项目命令 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], // 关键字 "author": "", // 作者(这里指开发者) "license": "ISC", // 标准(这个默认就ok) "dependencies": &#123; // 生产环境需要的依赖包 &#125;, "devDependencies": &#123; // 本地开发需要的依赖 "webpack": "^4.32.2", // 安装包 "webpack-cli": "^3.3.2" &#125;&#125; 接下来安装webpack,2种方法，一种是全局安装(通常我们不建议全局安装，因为每个项目需要的webpack版本可能会有不同，这里我们只说项目内安装)， 一种是项目内安装。 ¶项目内安装 npm install webpack webpack-cli --save-dev 等同于 npm install webpack webpack-cli -D 1npm install webpack webpack-cli --save-dev 安装完成后，输入 npx webpack -v 出现版本号说明安装成功 1npx webpack -v ¶现在新建文件，来体验下文件打包是什么样的 在文件夹的根目录下新建 index.html 文件，以及src文件夹。在src文件夹下面新建 index.js文件，并将下面相应的代码复制 ¶index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;欢迎来到蔓羊博客&lt;/div&gt; &lt;!-- 这里的dist 以及main.js 会在后面操作打包生成 --&gt; &lt;script src="./dist/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ¶index.js 1234567window.onload = function()&#123; var dom = document.createElement('div'); var root = document.getElementById('root'); dom.innerHTML = '这是我的测试博客'; root.appendChild(dom);&#125; 现在项目目录应该是这样： 1234567webpackdemo|- node-modules|- src|- index.html|- index.js|- package.json|- package-lock.json 建好了之后，打开git命令行工具，输入下面的命令。这个时候根目录下面会生成一个dist文件夹(ps:也就是通常所说的打包之后的文件)bi 这个时候可以在浏览器打开index.html,显示正常，说明打包成功 1npx webpack index.js npx：是webpack内置的打包命令。打包配置文件也是webpack默认的打包配置 以上就是webpack入门，想了解更多，请移步下篇文章 😄]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无插件上拉加载]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%97%A0%E6%8F%92%E4%BB%B6%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在写这篇文档之前，自己也写过移动端的上拉加载，不过一直以来都是用插件。 这次有时间吧原理好好梳理下； ¶原理： 浏览器内容高度(随内容多少变化)： document.documentelement.scrollHeight(ie的scrollHeight为document.body.scrollHeight) 滚动条的高度： dooument.documentelement.scrollTop(ie的scrollTop为document.body.scrollTop) 设备网页的可见高度(很多人说是设备的高度，自己斟酌)： widnow.screen.height 所以，当document.documentelement.scrollHeight = dooument.documentelement.scrollTop + widnow.screen.height时，就是滑到底部，需要请求下一页数据的时候 下面是核心代码： 12345678910111213141516171819window.onscroll = function(event)&#123; var screenHeight = window.screen.height; var scrollHeight = document.documentElement.scrollHeight; var scrollTop = document.documentElement.scrollTop; // 下面的10是在滑动在距离底部10px的时候,触发下一页数据请求.可自行调节 if(scrollHeight - (screenHeight + scrollTop) &lt; 10)&#123; //下面就是请求下一页数据的逻辑了，自行发挥 var htmlt = ''; for(var i = 0; i &lt; arr.length; i++)&#123; htmlt = htmlt + '&lt;p&gt;' + arr[i] + '&lt;/p&gt;'; &#125; var box = $('.box').html() $('.box').html(box + htmlt); &#125;&#125; 好用的话记得star呀~~😛 [上拉滚动 demo git地址]https://github.com/yagmdream/scroll]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客基础教程]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%85%A5%E9%97%A8%E7%BA%A7github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[¶准备：1.安装node.js环境并配置好 配置好之后，window + R 打开运行窗口，输入如下命令。出现版本号则说明安装成功 ¶2.github注册并新建一个仓库，仓库名必须和用户名相同，格式遵守：用户名.github.io 点击确定，仓库就建好了。 ¶3.在仓库上面最右边的菜单点击setting 然后向下拉到Github Pages,圈出的地方会有个网址（ps: 我这个是做了自定义域名），打开那个网址。你会发现项目在网络上可以打开了 ¶4.下来我们开始搭建安装Hexo 新建一个文件夹，进入文件夹，右键点击Git Bash Here打开命令行工具 输入命令, 开始全局安装hexo 1npm install hexo -g 安装完成之后输入 1hexo -v 出现下图，则安装成功 ¶5.输入hexo init进行项目初始化 出现下图 ，则说明项目初始化成功 ¶6.然后输入npm install安装所需的组件 1npm install ¶7.安装完成，就可以查看我们本地的博客了，输入： 1hexo s 打开圈出的地址：就能查看我们的博客雏形了😄 打开后正常应该是下面酱紫滴😝 ¶下来我们将博客放在我们github网址能访问的地方 ¶添加ssh(ps:这个是为了我们方便的将文章发布上去)，如果之前有添加过ssh，则略过 进入ssh文件夹1cs ~/.ssh ¶输入ls 查看是否有id_rsa，id_rsa.pub 这两个文件夹 1ls ¶如果没有，就输入下面的命令，然后回车。过程中会要求你输入github的账号和密码。 1ssh-keygen -t rsa -C &quot;你的github邮箱&quot; ¶输入完成之后。查看你的 C:\Users\hasee.ssh (ps:我的是这个) 大部分人应该是这个 C:\Users\window.ssh 文件件下面找到id_rsa.pub文件。 打开并复制里面的全部内容。然后登陆你的github,点击头像,选择settings ¶选择左侧边栏的SSH and GPG keys,点击New SSH keys ¶添加完成之后，输入下面的命令。看看是否添加成功 1ssh -T git@github.com ¶出现下面的提示，说明已经添加成功 ¶部署设置，在项目的根目录下找到_config.yml 文件，打开，拉到最下面，修改repository为你github博客的ssh 1234deploy: type: git repository: git@github.com:yagmdream/yagmdream.github.io.git branch: master ¶现在可以准备部署文章了，安装部署插件 1npm install hexo-deployer-git --save ¶安装完成之后，输入hexo d -g 生成及部署文章 1hexo d -g 现在可以线上访问： 用户名.github.io的地址 查看博客了😄]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mint-ui的cdn使用]]></title>
    <url>%2F2019%2F03%2F20%2Fmint-ui%E7%9A%84cdn%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[mint-ui平时使用多的经常是在类似 vue-cli 搭建好的框架中用import 引入，那如果我们cdn直接引入 script 。那里面的消息框该怎么用呢？ 12&lt;link rel="stylesheet" href="/Public/app_car_sales/css_v1_1/mint.ui.css"&gt;&lt;script src="/Public/app_car_sales/js_v1_1/mint.ui.js"&gt;&lt;/script&gt; toast、message调用看下面： 12345678//在 new Vue 对象的方法中直接调用就可以了this.$toast('这是一个提示窗');//message同理（全拼全部小写）this.$messagebox(&#123; title: '提示', message: '这是一个有确定按钮的弹窗', &#125;);]]></content>
      <tags>
        <tag>mint-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-super理解]]></title>
    <url>%2F2019%2F03%2F20%2Freact-super%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在看react的文档，发现react的逻辑都是以component为基础的。 比如： 123456class Clock extends React.Component &#123; constructor(props)&#123; super(props); console.log(this); &#125; &#125; 在es6中class的继承是通过extends关键字实现的。constructor 是类默认的构造方法。那么super是做什么用的？ ¶1.有super() or 无super() 我们现在注释掉super(props) 123456class Clock extends React.Component &#123; constructor(props)&#123; //super(props); console.log(this); &#125; &#125; 提示this不存在，就是说super是子类为了继承父类的this。 子类是没有自己的this的，它只能继承父类的this对象，然后对其操作。而super就是将父类的this继承给子类的。没有super，子类是无法拿到this对象的。 所以我们这样写 super() 123456class Clock extends React.Component &#123; constructor(props)&#123; super(); console.log(this); &#125; &#125; 打印出this为： ¶2.super(props) or super() 现在我们打印下 this.props 123456class Clock extends React.Component &#123; constructor(props)&#123; super(props); console.log(this.props); &#125; &#125; 现在是可以正常打印出结果的，现在将super中的props删掉 123456class Clock extends React.Component &#123; constructor(props)&#123; super(); console.log(this.props); &#125; &#125; 也就是说，如果我们想在constructor中使用props，super中就必须要带参数。否则是无法拿到值的。 所以还是建议，不论constructor中是否用到props ， 都这样写super(props); 这样不论什么情况都不会有拿不到值或者报错的情况 先写到这吧，要是有别的认知再来补充😝😝~~~]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react初识]]></title>
    <url>%2F2019%2F02%2F20%2Freact%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[新年伊始，领导说后面相面考虑用react开发，最近看了react的文档。真心话，觉得好复杂。个人想法ps: 也可能是因为之前用的vue，一时半会转不过来的原因 。希望不会有人打我😂 ¶话不多说 我们先来感受下 注意：react对node版本有要求: 1Node &gt;= 6 and npm &gt;= 5.2 首先先全局安装create-react-app这个脚手架， 为了后续执行命令用： 1npm install -g create-react-app 然后开始创建我们的第一个react项目 1create-react-app myapp //myapp是项目名 创建完成之后： 12cd myapp //进入项目yarn start //运行 用npm start 也可以，个人习惯 如果出现下面这个提示，说明3000端口被占用，找到这个运行的程序关掉就ok 然后重新运行 1yarn start 出现这个，我们的项目就顺利建成了 🙈🙈🙈~~]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdowm表情包]]></title>
    <url>%2F2019%2F02%2F20%2Fmarkdowm%E8%A1%A8%E6%83%85%E5%8C%85%2F</url>
    <content type="text"><![CDATA[markdown可以添加表情了😂 更多表情戳这里：https://www.webpagefx.com/tools/emoji-cheat-sheet/]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node创建一个服务]]></title>
    <url>%2F2019%2F02%2F11%2Fnode%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[¶node创建一个服务 在创建服务之前，要先安装node以及npm包管理（现在的node都带有默认的npm包管理） 通过这个demo演示创建服务的过程 12345678910111213141516171819202122232425262728//http.js//引入http模块var http = require('http');//创建一个服务http.createServer(function(request, response)&#123; //request 请求体 //response 响应体 //writeHead 设置请求头 response.writeHead(200, &#123;'Content-Type': 'text/html; charset = utf-8'&#125;) //默认一般会有2次访问。即页面选项卡前的图标，一般建议过滤掉 if(request.url !== '/favicon.ico')&#123; //在控制台打印 console.log('hello'); //网页打印 response.write('hello world'); //控制台打印出请求体 console.log(request); //请求完成之后，要结束响应 response.end('你好，世界'); &#125;&#125;).listen(8000); //listen 监听本地8000端口//提示监听的端口号console.log('Server runningat http://127.0.0.1:8000');]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加入购物车动画-基于fly.js插件]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%A8%E7%94%BB-%E5%9F%BA%E4%BA%8Efly-js%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[购物车飞入动画基于jquery的 fly.js插件,只需设置起点和终点的坐标即可，抛物线由fly.js来完成 资源下载地址：[https://github.com/amibug/fly]https://github.com/amibug/fly 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;飞入动画&lt;/title&gt; &lt;style&gt; .test&#123;background: red;width: 50px;height:50px;&#125; .box &#123; width: 100%; height: 1000px; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;飞入插件&lt;/div&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="fly.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 飞到的终点的坐标 var globalLeft = $('.box').offset().left; var globalTop = $('.box').offset().top - $(document).scrollTop() + 1000; //绑定点击事件 $('.box').on('click', fly); &lt;!-- 飞入执行 --&gt; function fly(event)&#123; console.log(10); var flyer = $('&lt;div class="test"&gt;&lt;/div&gt;'); flyer.fly(&#123; start: &#123; left: event.pageX, top: event.pageY-$(document).scrollTop() &#125;, end: &#123; top: globalTop, left: globalLeft, width: 0, height: 0, &#125;, onEnd: function()&#123; this.destroy(); &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery.range双滑块范围选择]]></title>
    <url>%2F2019%2F01%2F14%2FjQuery-range%E5%8F%8C%E6%BB%91%E5%9D%97%E8%8C%83%E5%9B%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[基于jquery的双滑块范围选择插件jquery.range.js 效果（颜色默认为绿色，这里我改了本地的css文件）： 1.首先载入jquery以及range插件相关文件： 123&lt;link rel="stylesheet" href="range.css"&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="range.min.js"&gt;&lt;/script&gt; 2.然后在需要展示滑块的地方放入下面代码（这里设置默认范围值为 0,80 ）： 1&lt;input type="hidden" value="0, 80" id="range" class="slider-input"/&gt; 3.在js中写入下面部分： 12345678910111213141516 $('.slider-input').jRange(&#123; from: 0, //滑块范围的初始值 to: 80, //滑块范围的终止值 step: 1, //设置步长 scale: [0,20,40,60,80], //滑动条下方的尺度变标签 format: '%s', //数值格式 width: 300, //进度条的宽度 showLabels: true, //是否显示滑动条下方的尺寸标签 showScale: false, //是否显示滑块上方的数值标签 isRange: true, //是否为选取范围 onstatechange: function(e)&#123; //滑块范围改变时触发的方法 console.log(e); &#125; &#125;); $('.slider-input').jRange('setValue', '25, 50'); //滑块赋值 上面的设置在文档中也有详细的描述，基本都可以满足我们的需求 jquery.range文档参考：https://github.com/nitinhayaran/jRange.]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
